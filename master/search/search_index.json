{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"genalyzer","text":"<p>Library for data converter and general sampled data analysis.</p> <p>Genalyzer is a C++ library that facilitates the computation of commonly used data-converter RF performance metrics in a standards-complaint manner. Genalyzer supports generation of waveforms for characterizing data-converters as well as the computation of performance metrics given the time- or frequency-domain response of data-converters to such waveforms. In other words, users not only have the option of selecting whether or not to opt for waveform generation to characterize data-convereters, but are also able to utilize time-series data or FFT of samples captured from a data-convereter to directly compute the desired performance metrics.</p> <p>Thus, Genalyzer can support a simulation-only scenario or a data-capture scenario. In the first case, the response of a data-converter is simulated given its specifications, in order to compute the expected performance metrics. In the second case, the response of a data-converter is available for Genalyzer to process in the form of a text or binary file. Genalyzer facilitates the computation of common data converter performance metrics in a standards-complaint manner. The terminology and definitions for various common performance metrics are adopted from the IEEE Standard for Terminology and Test Methods for Analog-to-Digital Converters (IEEE 1241-2010) and the IEEE Standard for Terminology and Test Methods of Digital-to-Analog Converter Devices (IEEE 1658-2011) both published by Instrumentation and Measurement/Waveform Generation, Measurement, and Analysis - Technical Committee 10 (IM/WM&amp;A - TC10).</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"cgenalyzer_8h/","title":"API Reference","text":""},{"location":"cgenalyzer_8h/#functions","title":"Functions","text":"Name Description gn_config_free free memory for configuration struct gn_config_set_ttype set configuration struct member: tone_type gn_config_set_npts set configuration struct member: npts gn_config_get_npts get configuration struct member: npts gn_config_set_sample_rate set configuration struct member: sample_rate gn_config_get_sample_rate get configuration struct member: sample_rate gn_config_set_data_rate set configuration struct member: data_rate gn_config_set_shift_freq set configuration struct member: shift_freq gn_config_set_num_tones set configuration struct member: num_tones gn_config_set_tone_freq set configuration struct member: tone_freq gn_config_set_tone_ampl set configuration struct member: tone_ampl gn_config_set_tone_phase set configuration struct member: tone_phase gn_config_set_fsr set configuration struct member: fsr gn_config_set_qres set configuration struct member: qres gn_config_set_noise_rms set configuration struct member: noise_rms gn_config_set_code_format set configuration struct member: code_format gn_config_set_nfft set configuration struct member: nfft gn_config_get_nfft get configuration struct member: nfft gn_config_set_fft_navg set configuration struct member: navg gn_config_set_win set configuration struct member: win gn_config_set_ssb_fund set configuration struct member: ssb_fund gn_config_set_ssb_rest set configuration struct member: ssb_rest gn_config_set_max_harm_order set configuration struct member: max_harm_order gn_config_set_dnla_signal_type set configuration struct member: dnla_signal_type gn_config_set_inla_fit set configuration struct member: inla_fit gn_config_set_ramp_start set configuration struct member: ramp_start gn_config_set_ramp_stop set configuration struct member: ramp_stop gn_config_get_code_density_size get configuration struct member: _code_density_size gn_config_gen_tone Configure tone parameters to be used in measurement. gn_config_gen_ramp Configure tone parameters to be used in measurement. gn_config_quantize Configure quantization parameters to be used in measurement. gn_config_histz_nla Configure parameters to compute histogram. gn_config_fftz Configure FFT parameters. gn_config_fa Generate sinusoidal tone based on supplied configuration. gn_config_fa_auto Generate sinusoidal tone based on supplied configuration without specifying tone manually. gn_gen_ramp Generate ramp based on supplied configuration. gn_gen_real_tone Generate sinusoidal tone based on supplied configuration. gn_gen_complex_tone Generate sinusoidal tone based on supplied configuration. gn_quantize Quantize waveform based on supplied configuration. gn_fftz Compute FFT of quantized input waveform. gn_histz Compute histogram of quantized waveform. gn_dnlz Compute histogram of quantized waveform. gn_inlz Compute histogram of quantized waveform. gn_get_wfa_results Do waveform analysis and all get results. gn_get_ha_results Do histogram analysis and get results. gn_get_dnla_results Do DNL analysis and get results. gn_get_inla_results Do INL analysis and get results. gn_get_fa_single_result Do Fourier analysis and get a single result. gn_get_fa_results Do Fourier analysis and all get results."},{"location":"cgenalyzer_8h/#types","title":"Types","text":"Name enum tone_type typedef struct gn_config_private * gn_config typedef enum tone_type tone_type"},{"location":"cgenalyzer_8h/#library-functions","title":"Library Functions","text":""},{"location":"cgenalyzer_8h/#function-gn_config_free","title":"function gn_config_free","text":"<pre><code>int gn_config_free(\ngn_config * c\n)\n</code></pre> <p>free memory for configuration struct </p> Parameter Description c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_ttype","title":"function gn_config_set_ttype","text":"<pre><code>int gn_config_set_ttype(\ntone_type ttype,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: tone_type </p> Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_npts","title":"function gn_config_set_npts","text":"<pre><code>int gn_config_set_npts(\nsize_t npts,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: npts </p> Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_get_npts","title":"function gn_config_get_npts","text":"<pre><code>int gn_config_get_npts(\nsize_t * npts,\ngn_config * c\n)\n</code></pre> <p>get configuration struct member: npts </p> Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_sample_rate","title":"function gn_config_set_sample_rate","text":"<pre><code>int gn_config_set_sample_rate(\ndouble sample_rate,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: sample_rate </p> Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_get_sample_rate","title":"function gn_config_get_sample_rate","text":"<pre><code>int gn_config_get_sample_rate(\ndouble * sample_rate,\ngn_config * c\n)\n</code></pre> <p>get configuration struct member: sample_rate </p> Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_data_rate","title":"function gn_config_set_data_rate","text":"<pre><code>int gn_config_set_data_rate(\ndouble data_rate,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: data_rate </p> Parameter Description data_rate Input data rate of the data converter c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_shift_freq","title":"function gn_config_set_shift_freq","text":"<pre><code>int gn_config_set_shift_freq(\ndouble shift_freq,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: shift_freq </p> Parameter Description shift_freq Shift frequency of the data converter c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_num_tones","title":"function gn_config_set_num_tones","text":"<pre><code>int gn_config_set_num_tones(\nsize_t num_tones,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: num_tones </p> Parameter Description num_tones Number of tones to generate c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_freq","title":"function gn_config_set_tone_freq","text":"<pre><code>int gn_config_set_tone_freq(\ndouble * tone_freq,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: tone_freq </p> Parameter Description tone_freq Input array of tone frequencies to generate c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_ampl","title":"function gn_config_set_tone_ampl","text":"<pre><code>int gn_config_set_tone_ampl(\ndouble * tone_ampl,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: tone_ampl </p> Parameter Description tone_ampl Input array of tone scales to generate c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_phase","title":"function gn_config_set_tone_phase","text":"<pre><code>int gn_config_set_tone_phase(\ndouble * tone_phase,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: tone_phase </p> Parameter Description tone_phase Input array of tone phases to generate c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_fsr","title":"function gn_config_set_fsr","text":"<pre><code>int gn_config_set_fsr(\ndouble fsr,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: fsr </p> Parameter Description fsr Full-scale range of the waveform c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_qres","title":"function gn_config_set_qres","text":"<pre><code>int gn_config_set_qres(\nint qres,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: qres </p> Parameter Description qres Quantization resolution c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_noise_rms","title":"function gn_config_set_noise_rms","text":"<pre><code>int gn_config_set_noise_rms(\ndouble noise_rms,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: noise_rms </p> Parameter Description qres Quantization noise c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_code_format","title":"function gn_config_set_code_format","text":"<pre><code>int gn_config_set_code_format(\nGnCodeFormat code_format,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: code_format </p> Parameter Description code_format Code format of data c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_nfft","title":"function gn_config_set_nfft","text":"<pre><code>int gn_config_set_nfft(\nsize_t nfft,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: nfft </p> Parameter Description nfft FFT order c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_get_nfft","title":"function gn_config_get_nfft","text":"<pre><code>int gn_config_get_nfft(\nsize_t * nfft,\ngn_config * c\n)\n</code></pre> <p>get configuration struct member: nfft </p> Parameter Description nfft FFT order c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_fft_navg","title":"function gn_config_set_fft_navg","text":"<pre><code>int gn_config_set_fft_navg(\nsize_t fft_navg,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: navg </p> Parameter Description navg Num. of FFTs to average c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_win","title":"function gn_config_set_win","text":"<pre><code>int gn_config_set_win(\nGnWindow win,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: win </p> Parameter Description win Window function used c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_ssb_fund","title":"function gn_config_set_ssb_fund","text":"<pre><code>int gn_config_set_ssb_fund(\nint ssb_fund,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: ssb_fund </p> Parameter Description ssb_fund Single side bin fundamental c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_ssb_rest","title":"function gn_config_set_ssb_rest","text":"<pre><code>int gn_config_set_ssb_rest(\nint ssb_rest,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: ssb_rest </p> Parameter Description ssb_rest Single side bins rest c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_max_harm_order","title":"function gn_config_set_max_harm_order","text":"<pre><code>int gn_config_set_max_harm_order(\nint max_harm_order,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: max_harm_order </p> Parameter Description max_harm_order Max order of harmonic c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_dnla_signal_type","title":"function gn_config_set_dnla_signal_type","text":"<pre><code>int gn_config_set_dnla_signal_type(\nGnDnlSignal dnla_signal_type,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: dnla_signal_type </p> Parameter Description dnla_signal_type DNL analysis signal type c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_inla_fit","title":"function gn_config_set_inla_fit","text":"<pre><code>int gn_config_set_inla_fit(\nGnInlLineFit inla_fit,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: inla_fit </p> Parameter Description inla_fit INL analysis line fit c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_ramp_start","title":"function gn_config_set_ramp_start","text":"<pre><code>int gn_config_set_ramp_start(\ndouble ramp_start,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: ramp_start </p> Parameter Description ramp_start start value of ramp c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_set_ramp_stop","title":"function gn_config_set_ramp_stop","text":"<pre><code>int gn_config_set_ramp_stop(\ndouble ramp_stop,\ngn_config * c\n)\n</code></pre> <p>set configuration struct member: ramp_stop </p> Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_get_code_density_size","title":"function gn_config_get_code_density_size","text":"<pre><code>int gn_config_get_code_density_size(\nsize_t * code_density_size,\ngn_config * c\n)\n</code></pre> <p>get configuration struct member: _code_density_size </p> Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_gen_tone","title":"function gn_config_gen_tone","text":"<pre><code>int gn_config_gen_tone(\ntone_type ttype,\nsize_t npts,\ndouble sample_rate,\nsize_t num_tones,\ndouble * tone_freq,\ndouble * tone_ampl,\ndouble * tone_phase,\ngn_config * c\n)\n</code></pre> <p>Configure tone parameters to be used in measurement. </p> Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP npts Number of sample points in the generated waveform sample_rate Input Sample rate of the data converter num_tones Number of tones to generate tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate c Configuration struct containing tone parameters <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_gen_ramp","title":"function gn_config_gen_ramp","text":"<pre><code>int gn_config_gen_ramp(\nsize_t npts,\ndouble ramp_start,\ndouble ramp_stop,\ngn_config * c\n)\n</code></pre> <p>Configure tone parameters to be used in measurement. </p> Parameter Description npts Number of sample points in the generated waveform ramp_start Input start value of ramp ramp_stop Input stop value of ramp c Configuration struct containing ramp parameters <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_quantize","title":"function gn_config_quantize","text":"<pre><code>int gn_config_quantize(\nsize_t npts,\ndouble fsr,\nint qres,\ndouble qnoise,\ngn_config * c\n)\n</code></pre> <p>Configure quantization parameters to be used in measurement. </p> Parameter Description npts Number of sample points in the generated waveform fsr Full-scale range of the waveform qres Quantization resolution qnoise Quantization noise c Configuration structure <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_histz_nla","title":"function gn_config_histz_nla","text":"<pre><code>int gn_config_histz_nla(\nsize_t npts,\nint qres,\ngn_config * c\n)\n</code></pre> <p>Configure parameters to compute histogram. </p> Parameter Description npts Number of sample points in the generated waveform qres Quantization resolution c Configuration structure <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_fftz","title":"function gn_config_fftz","text":"<pre><code>int gn_config_fftz(\nsize_t npts,\nint qres,\nsize_t navg,\nsize_t nfft,\nGnWindow win,\ngn_config * c\n)\n</code></pre> <p>Configure FFT parameters. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_fa","title":"function gn_config_fa","text":"<pre><code>int gn_config_fa(\ndouble fixed_tone_freq,\ngn_config * c\n)\n</code></pre> <p>Generate sinusoidal tone based on supplied configuration. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_config_fa_auto","title":"function gn_config_fa_auto","text":"<pre><code>int gn_config_fa_auto(\nuint8_t ssb_width,\ngn_config * c\n)\n</code></pre> <p>Generate sinusoidal tone based on supplied configuration without specifying tone manually. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_gen_ramp","title":"function gn_gen_ramp","text":"<pre><code>int gn_gen_ramp(\ndouble ** out,\ngn_config * c\n)\n</code></pre> <p>Generate ramp based on supplied configuration. </p> Parameter Description out Output array of ramp generated c Configuration structure of test and waveform to generate"},{"location":"cgenalyzer_8h/#function-gn_gen_real_tone","title":"function gn_gen_real_tone","text":"<pre><code>int gn_gen_real_tone(\ndouble ** out,\ngn_config * c\n)\n</code></pre> <p>Generate sinusoidal tone based on supplied configuration. </p> Parameter Description out Output array of generated tone c Configuration structure containing test parameters <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_gen_complex_tone","title":"function gn_gen_complex_tone","text":"<pre><code>int gn_gen_complex_tone(\ndouble ** outi,\ndouble ** outq,\ngn_config * c\n)\n</code></pre> <p>Generate sinusoidal tone based on supplied configuration. </p> Parameter Description outi In-phase output array of generated tone outq Quadrature output array of generated tone c Configuration structure containing test parameters <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_quantize","title":"function gn_quantize","text":"<pre><code>int gn_quantize(\nint32_t ** out,\nconst double * in,\ngn_config * c\n)\n</code></pre> <p>Quantize waveform based on supplied configuration. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_fftz","title":"function gn_fftz","text":"<pre><code>int gn_fftz(\ndouble ** out,\nconst int32_t * in_i,\nconst int32_t * in_q,\ngn_config * c\n)\n</code></pre> <p>Compute FFT of quantized input waveform. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_histz","title":"function gn_histz","text":"<pre><code>int gn_histz(\nuint64_t ** hist,\nsize_t * hist_len,\nconst int32_t * qwf,\ngn_config * c\n)\n</code></pre> <p>Compute histogram of quantized waveform. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_dnlz","title":"function gn_dnlz","text":"<pre><code>int gn_dnlz(\ndouble ** dnl,\nsize_t * dnl_len,\nconst uint64_t * hist,\ngn_config * c\n)\n</code></pre> <p>Compute histogram of quantized waveform. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_inlz","title":"function gn_inlz","text":"<pre><code>int gn_inlz(\ndouble ** inl,\nsize_t * inl_len,\nconst double * dnl,\ngn_config * c\n)\n</code></pre> <p>Compute histogram of quantized waveform. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_wfa_results","title":"function gn_get_wfa_results","text":"<pre><code>int gn_get_wfa_results(\nchar *** rkeys,\ndouble ** rvalues,\nsize_t * results_size,\nconst int32_t * qwf,\ngn_config * c\n)\n</code></pre> <p>Do waveform analysis and all get results. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_ha_results","title":"function gn_get_ha_results","text":"<pre><code>int gn_get_ha_results(\nchar *** rkeys,\ndouble ** rvalues,\nsize_t * results_size,\nconst uint64_t * hist,\ngn_config * c\n)\n</code></pre> <p>Do histogram analysis and get results. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_dnla_results","title":"function gn_get_dnla_results","text":"<pre><code>int gn_get_dnla_results(\nchar *** rkeys,\ndouble ** rvalues,\nsize_t * results_size,\nconst double * dnl,\ngn_config * c\n)\n</code></pre> <p>Do DNL analysis and get results. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_inla_results","title":"function gn_get_inla_results","text":"<pre><code>int gn_get_inla_results(\nchar *** rkeys,\ndouble ** rvalues,\nsize_t * results_size,\nconst double * inl,\ngn_config * c\n)\n</code></pre> <p>Do INL analysis and get results. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_fa_single_result","title":"function gn_get_fa_single_result","text":"<pre><code>int gn_get_fa_single_result(\ndouble * rvalue,\nconst char * metric_name,\ndouble * fft_ilv,\ngn_config * c\n)\n</code></pre> <p>Do Fourier analysis and get a single result. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#function-gn_get_fa_results","title":"function gn_get_fa_results","text":"<pre><code>int gn_get_fa_results(\nchar *** rkeys,\ndouble ** rvalues,\nsize_t * results_size,\ndouble * fft_ilv,\ngn_config * c\n)\n</code></pre> <p>Do Fourier analysis and all get results. </p> <p>Return: 0 on success, non-zero otherwise </p>"},{"location":"cgenalyzer_8h/#library-types","title":"Library Types","text":""},{"location":"cgenalyzer_8h/#enum-tone_type","title":"enum tone_type","text":"Enumerator Value Description REAL_COSINE REAL_SINE COMPLEX_EXP"},{"location":"cgenalyzer_8h/#typedef-gn_config","title":"typedef gn_config","text":"<pre><code>typedef struct gn_config_private* gn_config;\n</code></pre>"},{"location":"cgenalyzer_8h/#typedef-tone_type","title":"typedef tone_type","text":"<pre><code>typedef enum tone_type tone_type;\n</code></pre> <p>Updated on 2023-04-19 at 18:03:12 +0000</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#fourier-analysis","title":"Fourier Analysis","text":"<p>In the following working example, data from an ADALM-PLUTO is used to perform a Fourier analysis as shown below. Note that in the following example, it is assumed that the data is available in the form of a json file. It can be replaced by any other means of loading this data.</p> CPython <pre><code>#include \"cgenalyzer.h\"\n#include \"../tests/test_genalyzer.h\"\n#include &lt;stdlib.h&gt;\n\nint main(int argc, const char* argv[])\n{\n// read test waveform filename\nconst char* test_filename = \"../tests/test_vectors/test_Pluto_DDS_data_1658159639196.json\";\n\nint err_code;\nint32_t *ref_qwfi, *ref_qwfq;\ndouble *fft_out;\nsize_t results_size;\nchar **rkeys;\ndouble *rvalues, sfdr;\n\n// read parameters\ntone_type ttype;\nint qres;\nunsigned long long npts, navg, nfft, tmp_win, num_tones;\ndouble *freq;\nGnWindow win;    err_code = read_scalar_from_json_file(test_filename, \"wf_type\", (void*)(&amp;ttype), UINT64);\nerr_code = read_scalar_from_json_file(test_filename, \"qres\", (void*)(&amp;qres), INT32);\nerr_code = read_scalar_from_json_file(test_filename, \"npts\", (void*)(&amp;npts), UINT64);\nerr_code = read_scalar_from_json_file(test_filename, \"navg\", (void*)(&amp;navg), UINT64);\nerr_code = read_scalar_from_json_file(test_filename, \"nfft\", (void*)(&amp;nfft), UINT64);\nerr_code = read_scalar_from_json_file(test_filename, \"num_tones\", (void*)(&amp;num_tones), UINT64);\nfreq = (double*)calloc(num_tones, sizeof(double));\nif (num_tones &gt; 1)\nerr_code = read_array_from_json_file(test_filename, \"freq\", freq, DOUBLE, num_tones);\nelse\nerr_code = read_scalar_from_json_file(test_filename, \"freq\", (void*)(freq), DOUBLE);\nerr_code = read_scalar_from_json_file(test_filename, \"win\", (void*)(&amp;tmp_win), UINT64);\nif (tmp_win==1)\nwin = GnWindowBlackmanHarris;\nelse if (tmp_win==2)\nwin = GnWindowHann; else if (tmp_win==3)\nwin = GnWindowNoWindow;\n\n// read reference waveforms    \nref_qwfi = (int32_t*)malloc(npts*sizeof(int32_t));\nerr_code = read_array_from_json_file(test_filename, \"test_vec_i\", ref_qwfi, INT32, npts);\nref_qwfq = (int32_t*)malloc(npts*sizeof(int32_t));\nerr_code = read_array_from_json_file(test_filename, \"test_vec_q\", ref_qwfq, INT32, npts);\n\n// configuration\ngn_config c = NULL;\nerr_code = gn_config_fftz(npts, qres, navg, nfft, win, &amp;c);\n\n// FFT of waveform\nerr_code = gn_fftz(&amp;fft_out, ref_qwfi, ref_qwfq, &amp;c);\n\n// Configure Fourier analysis\nerr_code = gn_config_fa(freq[0], &amp;c);\nerr_code = gn_get_fa_results(&amp;rkeys, &amp;rvalues, &amp;results_size, fft_out, &amp;c);\n\nprintf(\"\\nAll Fourier Analysis Results:\\n\");\nfor (size_t i = 0; i &lt; results_size; i++)\nprintf(\"%4zu%20s%20.6f\\n\", i, rkeys[i], rvalues[i]);\n\nerr_code = gn_get_fa_single_result(&amp;sfdr, \"sfdr\", fft_out, &amp;c);\nprintf(\"SFDR - %20.6f\\n\", sfdr);\n\n// free memory\nfree(ref_qwfi);\nfree(ref_qwfq);\nfree(fft_out);\nfree(rvalues);\nfor (size_t i = 0; i &lt; results_size; ++i)\nfree(rkeys[i]);\nfree(rkeys);\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> <pre><code>import genalyzer, os, json, glob, pprint\nimport matplotlib.pyplot as plt\n\ntest_dir = os.path.join(*[\"..\", \"..\", \"..\", \"tests\", \"test_vectors\"])\nloc = os.path.dirname(__file__)\n\nf = glob.glob(os.path.join(loc, test_dir, \"test_Pluto_DDS_data_1658159639196.json\"))\na = open(f[0])\ndata = json.load(a)\nif data['num_tones'] == 1:\n    freq_list = [data['freq']]\nelse:\n    freq_list = data['freq']\n\nqwfi = data['test_vec_i']\nqwfi = [int(i) for i in qwfi]\nqwfq = data['test_vec_q']\nqwfq = [int(i) for i in qwfq]\n\n# configure\nc = genalyzer.config_fftz(data['npts'], data['qres'], data['navg'], data['nfft'], data['win']-1)\ngenalyzer.config_fa(freq_list[0], c)\n\n# compute FFT\nfft_out_i, fft_out_q = genalyzer.fftz(qwfi, qwfq, c)\nfft_out = [val for pair in zip(fft_out_i, fft_out_q) for val in pair]\n\n# get all Fourier analysis results\nall_results = genalyzer.get_fa_results(fft_out, c)\n\n# get a single Fourier analysis result\nsfdr = genalyzer.get_fa_single_result(\"sfdr\", fft_out, c)\n\n# display results\npprint.pprint(all_results)\nprint('SFDR - ', sfdr)\n\n# free memory\ngenalyzer.config_free(c)    \n</code></pre> <p>A summary of the most important results displayed and a brief explanation is as follows:</p> Result Name Description fsnr Full-scale Signal-to-Noise Ratio snr Signal-to-Noise Ratio sinad Signal-to-Noise and Distortion Ratio sfdr Spurious Free Dynamic Range abn Analysis Band Noise Power nsd Noise Spectral Density carrierindex Index of carrier tone maxspurindex Index of max. spur tone ab_nbins # of bins in analysis band ab_rss Analysis band received signal strength hd_nbins # of bins in used in computing harmonic distortion hd_rss Harmonic distortion band received signal strength imd_nbins # of bins in used in computing inter-modulation distortion imd_rss Inter-modulation distortion band received signal strength thd_nbins # of bins in used in computing total harmonic distortion thd_rss Total harmonic distortion band received signal strength"},{"location":"examples/#waveform-analysis","title":"Waveform Analysis","text":"<p>In the following working example, genalyzer is used to generate a cosine-tone waveform, then the effect of a data-converter on this waveform is simulated and a basic waveform analysis is performed as shown below.</p> CPython <pre><code>#include \"cgenalyzer.h\"\n#include &lt;stdlib.h&gt;\n\nint main(int argc, const char* argv[])\n{\n// parameters\ntone_type ttype = REAL_COSINE;\ndouble fsr = 3.0, qnoise = pow(10.0, -60.0 / 20.0);\nint qres = 12;\ndouble fs = 5000000.0;\nunsigned long long npts = 8192, num_tones = 1;\ndouble freq[] = {50000.0}, scale[] = {0.5}, phase[] = {0.2};\n\n// waveforms\ndouble *awf;\nint32_t *qwf;\n\n// results\nsize_t results_size;\nchar **rkeys;\ndouble *rvalues;\n\n// configuration\nint err_code;\ngn_config c = NULL;\nerr_code = gn_config_gen_tone(ttype, npts, fs, num_tones, freq, scale, phase, &amp;c);\nerr_code = gn_config_quantize(npts, fsr, qres, qnoise, &amp;c);\n\n// generate waveform\nerr_code = gn_gen_real_tone(&amp;awf, &amp;c);\n\n// quantize waveform\nerr_code = gn_quantize(&amp;qwf, awf, &amp;c);\n\n// do waveform analysis\nerr_code = gn_get_wfa_results(&amp;rkeys, &amp;rvalues, &amp;results_size, qwf, &amp;c);        // print results\nprintf(\"All Waveform Analysis Results:\\n\");\nfor (size_t i = 0; i &lt; results_size; i++)\nprintf(\"%4zu%20s%20.6f\\n\", i, rkeys[i], rvalues[i]);\n\n// free memory\nfree(qwf);\nfree(awf);\nfor (size_t i = 0; i &lt; results_size; i++)\nfree(rkeys[i]);\nfree(rkeys);\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> <pre><code>import genalyzer, pprint\n\nc = genalyzer.config_gen_tone(0, 8192, 5000000.0, 1, [50000.0], [0.5], [0.2])\ngenalyzer.config_quantize(8192, 3.0, 12, pow(10.0, -60.0 / 20.0), c)\n\nawf = genalyzer.gen_real_tone(c)\nqwf = genalyzer.quantize(awf, c)\nwfa_results = genalyzer.get_wfa_results(qwf, c)\npprint.pprint(wfa_results)\ngenalyzer.config_free(c)\n</code></pre> <p>A summary of the results displayed and a brief explanation is as follows:</p> Result Name Description Notes min Min. value max Max. value mid Mid value range Numerical range max-min avg Mean value rms RMS value rmsac RMS (AC) Evaluated as rms2-avg2 min_index Index of min. value max_index Index of max. value"},{"location":"examples/#histogram-analysis","title":"Histogram Analysis","text":"<p>In the following working example, genalyzer is used to generate a ramp waveform, then the effect of a data-converter on this waveform is simulated and a basic histogram analysis is performed as shown below.</p> CPython <pre><code>#include \"cgenalyzer.h\"\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint main(int argc, const char* argv[])\n{\n// parameters\ndouble fsr = 3.0, qnoise = pow(10.0, -60.0 / 20.0);\nint qres = 12;\nunsigned long long npts = 8192, ramp_start = 0, ramp_stop = 2;\n\n// waveforms\ndouble *awf;\nint32_t *qwf;\n\n// results\nuint64_t *hist;\nsize_t results_size, hist_len;\nchar **rkeys;\ndouble *rvalues;\n\n// configuration\nint err_code;\ngn_config c = NULL;\nerr_code = gn_config_gen_ramp(npts, ramp_start, ramp_stop, &amp;c);\nerr_code = gn_config_quantize(npts, fsr, qres, qnoise, &amp;c);\n\n// generate waveform\nerr_code = gn_gen_ramp(&amp;awf, &amp;c);\n\n// quantize waveform\nerr_code = gn_quantize(&amp;qwf, awf, &amp;c);\n\n// compute histogram\nerr_code = gn_histz(&amp;hist, &amp;hist_len, qwf, &amp;c);\n\n// do waveform analysis\nerr_code = gn_get_ha_results(&amp;rkeys, &amp;rvalues, &amp;results_size, hist, &amp;c);\n\n// print results\nprintf(\"All Waveform Analysis Results:\\n\");\nfor (size_t i = 0; i &lt; results_size; i++)\nprintf(\"%4zu%20s%20.6f\\n\", i, rkeys[i], rvalues[i]);\n\n// free memory\nfree(qwf);\nfree(awf);\nfor (size_t i = 0; i &lt; results_size; i++)\nfree(rkeys[i]);\nfree(rkeys);\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> <pre><code>import genalyzer, pprint\n\nc = genalyzer.config_gen_ramp(8192, 0, 2)\ngenalyzer.config_quantize(8192, 3.0, 12, pow(10.0, -60.0 / 20.0), c)\n\nawf = genalyzer.gen_ramp(c)\nqwf = genalyzer.quantize(awf, c)\nhist = genalyzer.histz(qwf, c)\nha_results = genalyzer.get_ha_results(hist, c)\npprint.pprint(ha_results)\ngenalyzer.config_free(c)\n</code></pre> <p>A summary of the results displayed and a brief explanation is as follows:</p> Result Name Description sum Sum of histogram hits first_nz_index First non-zero bin index last_nz_index Last non-zero bin index nz_range Non-zero bin range"},{"location":"setup/","title":"Installation","text":""},{"location":"setup/#windows","title":"Windows","text":""},{"location":"setup/#linux","title":"Linux","text":""},{"location":"setup/#macos","title":"macOS","text":""},{"location":"setup/#bindings","title":"Bindings","text":""},{"location":"setup/#python","title":"Python","text":""},{"location":"sim/","title":"Simulation","text":"<p>A number of tests that genalyzer supports assume that the waveform that is analyzed contain one tone or two tones. genalyzer does not support analysis of generic waveforms, which can be decomposed into multiple tone frequencies. In this section, a demonstration of single-tone based measurements supported by genalyzer are described. MATLAB and Python bindings are used to describe the results using the computed FFT and its analysis. First a brief overview of configuring ADALM-PLUTO is shown. For more details, see this page on streaming samples from a supported device using ADI Transceiver Toolbox for MATLAB and this page for the corresponding details when using PyADI-IIO.</p> Configuring ADALM-PLUTO for Tone-Based Measurement in RF Loopback <p>An ADALM-PLUTO is connected in RF loopback and is configured to transmit a 2 MHz complex tone, with the sample rate set to 15.36 MSPS. </p> MATLAB <p>The MATLAB and Python code snippets are shown below.</p> MATLABPython <pre><code>%% Tx set up\ntx = adi.Pluto.Tx;\ntx.uri = 'ip:pluto'; \ntx.DataSource = 'DDS';\ntx.DDSFrequencies = [2e6 2e6; 0 0]; % set DDS complex tone freq to 2 MHz \ntx.DDSPhases = [90e3 0; 0 0]; % expressed in millidegrees\ntx.DDSScales = [1 1; 0 0];\ntx.CenterFrequency = 2.4e9;\ntx.EnableCustomFilter = true;\ntx.CustomFilterFileName = 'LTE10_MHz.ftr'; % sets PlutoSDR sample-rate to 15.36 MSPS\ntx.AttenuationChannel0 = -10;\ntx();\npause(1);\n\n%% Rx set up\nrx = adi.Pluto.Rx('uri','ip:pluto');\nrx.CenterFrequency = tx.CenterFrequency;\nrx.EnableCustomFilter = true;\nrx.CustomFilterFileName = 'LTE10_MHz.ftr';\nrx.GainControlModeChannel0 = 'fast_attack';\ny = rx();\ny_re = real(y);\ny_im = imag(y);\n\ntx.release();\nrx.release();\n</code></pre> <pre><code># Create radio\nsdr = adi.Pluto()\n\n# Configure properties\nsdr.rx_lo = 2400000000\nsdr.tx_lo = 2400000000\nsdr.tx_cyclic_buffer = True\nsdr.tx_hardwaregain_chan0 = -10\nsdr.gain_control_mode_chan0 = \"fast_attack\"\nsdr.filter = \"LTE10_MHz.ftr\"\n\nfs = int(sdr.sample_rate)\ntone_freq_hz = 2000000  # In Hz\ntone_scale = 1.0  # Range: 0-1.0\ntx_channel = 0  # Starts at 0\nsdr.dds_single_tone(tone_freq_hz, tone_scale, tx_channel)\n\n# Collect data\nx = sdr.rx()\n</code></pre> Using genalyzer and ADALM-PLUTO to Compute Tone-Based Measurements for ADALM-PLUTO in RF Loopback <p>In this section, an example on how to use genalyzer for calculating Spurious free dynamic range (SFDR) is provided. Doc in progress.</p> <p>Spurious free dynamic range (SFDR) specifies the capability of the ADC and the system to decipher a carrier signal from other noise or any other spurious frequency. It represents the smallest power signal that can be distinguished from a large interfering signal. Mathematically, it is the ratio between the root mean square (rms) value of the power of a carrier and the rms value of the next most significant spurious signal seen in the frequency domain, such as in a fast Fourier transform (FFT). Hence, by definition, this dynamic range must be free of other spurious frequencies, or spurs. </p> <p>SFDR is quantified as the range, in units of power (dBc), relative from the carrier of interest to the power of the next most significant frequency. However, it also could be referenced to a full-scale signal in units of power (dBFS). This is an important distinction since the carrier of interest may be a relatively lower power signal that is well below the full-scale input to the ADC. When this is the case, the SFDR becomes paramount in distinguishing the signal from other noise and spurious frequencies.</p> <p>A harmonic frequency is an integer multiple of the fundamental frequency. Hence, the SFDR typically will be dominated by the dynamic range between a carrier frequency and the second or third harmonic of the fundamental frequency of interest. </p> <p>In this example, these ideas are demonstrated by using MATLAB's <code>calllib</code> interface to genalyzer. A link to the complete MATLAB script is shown at the bottom of this page. </p> <p>The first step is to create an opaque configuration struct. Using MATLAB and Python bindings, this is done as shown by the code snippet below. </p> MATLABPython <pre><code>% measurement settings \ndomain = 0; % 0 - TIME; 1 - FREQ\ntype = 2; \nnfft = length(y);\nnavg = 1;\nfs = 15.36e6;\nfsr = 0;\nres = 12;\nwindow = 1; % 0 - BlackmanHarris, 1 - Hann, 2 - Rect\n\n% setup measurement for time-domain measurement\nc = libpointer; % create a null pointer\ncalllib('libgenalyzer', 'gn_config_tone_meas', ...\n    c, domain, type, nfft, navg, fs, fsr, res, window, false, false, false);\n</code></pre> <pre><code># setup measurement\ninputs = dict()\ninputs[\"domain_wf\"] = 0\ninputs[\"type_wf\"] = 2\ninputs[\"nfft\"] = len(x)\ninputs[\"navg\"] = 1\ninputs[\"fs\"] = fs\ninputs[\"fsr\"] = 0\ninputs[\"res\"] = 12\ninputs[\"win\"] = 1\ninputs[\"freq\"] = [0]\ninputs[\"phase\"] = [0]\ninputs[\"scale\"] = [0]\nconfig_obj = genalyzer.gn_params(**inputs)\nc = genalyzer.config_tone_meas(config_obj)\n</code></pre> <p>Now, the configuration struct contains the measurement settings in order to calculate the desired metric. SFDR calculation is done as shown in the following code snippets. </p> MATLABPython <pre><code>% calculating SFDR using the time-domain waveform\nerr_code = libpointer('uint32Ptr',0);\nfft_len = libpointer('uint64Ptr',0);\nmetric = char('SFDR');\nfft_time_re = libpointer('doublePtrPtr', zeros(nfft, 1));\nfft_time_im = libpointer('doublePtrPtr',  zeros(nfft, 1));\ny_interleaved = [y_re'; y_im'];\ny_interleaved = y_interleaved(:);\ny_interleavedPtr = libpointer('int32Ptr', y_interleaved);\nsfdr_time = calllib('libgenalyzer', 'gn_metric', c, y_interleavedPtr, metric, fft_time_re, fft_time_im, fft_len, err_code);\n</code></pre> <pre><code># compute SFDR\nresult, fft_i, fft_q, err_code = genalyzer.metric_t(c, x_intrlv, \"SFDR\")\n</code></pre> <p>Note that the FFT calculated for analysis and computing the desired metric is returned by genalyzer. Plotting the FFT computed using genalyzer, we can see that the second harmonic at 4 MHz and its image dominate the remaining spurs. Note that the third harmonic and its image are filtered out by the programmable filter coefficients loaded into ADALM-PLUTO. </p> <p></p> <p>Since SFDR is by definition, free of spurious frequencies, by examining the above plot, one can estimate SFDR to be around 50 dBc. This values agrees with the SFDR computed by genalyzer.  <pre><code>SFDR (time) - 49.742253\n</code></pre></p> <p>Note that genalyzer can be configured to compute performance metrics from frequency-domain data as well. In other words, genalyzer can be configured to skip the FFT computation step and only perform analysis of the FFT provided as input. Note that passing a <code>1</code> instead of a <code>0</code> to the <code>domain</code> argument controls this configuration. This is shown by the MATLAB code snippet below. The same can be accomplished using Python bindings as well. </p> MATLABPython <pre><code>% setup measurement for freq-domain measurement\nc = libpointer;\ndomain = 1; % 0 - TIME; 1 - FREQ\ncalllib('libgenalyzer', 'gn_config_tone_meas', ...\n    c, domain, type, nfft, navg, fs, fsr, res, window, false, false, false);\n\n% calculating SFDR using the FFT calculated from time-domain waveform\nerr_code = libpointer('uint32Ptr',0);\nfft_len = libpointer('uint64Ptr',0);\nfft_y = fft(hann(length(y)).*y);\nffty_interleaved = [real(fft_y)'; imag(fft_y).'];\nffty_interleaved = ffty_interleaved(:);\nffty_interleavedPtr = libpointer('doublePtr', ffty_interleaved);\nfft_freq_re = libpointer('doublePtrPtr', zeros(nfft, 1));\nfft_freq_im = libpointer('doublePtrPtr',  zeros(nfft, 1));\nsfdr_freq = calllib('libgenalyzer', 'gn_metric', c, ffty_interleavedPtr, metric, fft_freq_re, fft_freq_im, fft_len, err_code);\n</code></pre> <pre><code># update domain\ninputs[\"domain_wf\"] = 1\nconfig_obj = genalyzer.gn_params(**inputs)\nc = genalyzer.config_tone_meas(config_obj)\n# compute SFDR\nresult, fft_i, fft_q, err_code = genalyzer.metric_t(c, x_intrlv, \"SFDR\")\n</code></pre> <p>The calculated SFDR matches the corresponding result obtained using time-domain waveform closely. <pre><code>SFDR (freq) - 49.742421\n</code></pre></p> <p>Similarly, Signal-to-Noise-and-Distortion (SINAD, or S/(N + D) is the ratio of the rms signal amplitude to the mean value of the root-sum-square (RSS) of all other spectral components, including harmonics, but excluding DC. SINAD is a therefore, an indicator of the overall dynamic performance of an ADC because it includes all components which make up noise and distortion. To compute SINAD, only the </p>"},{"location":"theory/","title":"Usage Model","text":""},{"location":"theory/#overview","title":"Overview","text":"<p>Within Genalyzer, bindings to the C++ library are provided to enable users to write C-, Python-, or MATLAB-based scripts to compute the desired performance metrics. In all three cases, the overall structure of a script that links to genalyzer is similar, as shown in more detail in the next subsection. The overall structure in a simulation-only scenario consists of three stages:</p> <ul> <li>Configure test</li> <li>Generate waveform</li> <li>Compute metric</li> </ul> <p>In the scenario where either the ADC codes or the FFT of the captured ADC codes are available, the structure would be </p> <ul> <li>Configure test</li> <li>Load waveform</li> <li>Compute metric</li> </ul> <p>In other words, only the second step would change. </p> <p>The overall structure of a C-example that utilizes genalyzer library in the first scenario is shown by the following example. <pre><code>#include \"cgenalyzer.h\"\n\nint main(int argc, char *argv[]) {  // opaque config struct that will contain config settings\ngn_config c = NULL;  // configure test\nerr_code = gn_config_gen_tone(..., &amp;c);\nerr_code = gn_config_quantize(..., &amp;c);\n\n// generate waveform and quantize\nerr_code = gn_gen_real_tone(..., &amp;c);\nerr_code = gn_quantize(..., &amp;c);\n\n// compute metrics\nerr_code = gn_get_fa_single_result(&amp;sfdr, \"sfdr\", ..., &amp;c);\n\n// free memory\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> As shown in this (incomplete) illustrative example, a configuration struct is passed to various stages without having to pass the same relevant parameters over and over. </p> <p>The overall structure of a C-example in the second scenario is shown by the following example. <pre><code>#include \"cgenalyzer.h\"\n\nint main(int argc, char *argv[]) {  // opaque config struct that will contain config settings\ngn_config c = NULL;  // configure test\nerr_code = gn_config_fft(..., &amp;c);\n\n// read ADC codes from file\nerr_code = read_array_from_json_file(filename, \"adc_output_i\", adc_i, ...);\nerr_code = read_array_from_json_file(filename, \"adc_output_q\", adc_q, ...);\n\n// compute FFT\nerr_code = gn_fftz(&amp;fft_out, adc_i, adc_q, &amp;c);\n\n// compute metrics\nerr_code = gn_get_fa_single_result(&amp;sfdr, \"sfdr\", fft_out, &amp;c);\n\n// free memory\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> If on the other hand, the FFT is pre-computed and genalyzer is expected to compute the desired performance metric alone, then only the configuration of FFT related parameters is needed in order for genalyzer to compute the desired performance metric. Note that in the following example, it is assumed that the FFT data is available in the form of a json file. It can be replaced by any other means of loading this data. <pre><code>#include \"cgenalyzer.h\"\n\nint main(int argc, char *argv[]) {  // opaque config struct that will contain config settings\ngn_config c = NULL;  // configuration\nerr_code = gn_config_fft(..., &amp;c);\n\n// read FFT of ADC codes from file\nerr_code = read_array_from_json_file(filename, \"fft_test_vec\", fft_out, ...);\n\n// compute metrics\nerr_code = gn_get_fa_single_result(&amp;sfdr, \"sfdr\", fft_out, &amp;c);\n\n// free memory\ngn_config_free(&amp;c);\n\nreturn 0;\n}\n</code></pre> As highlighted by all three illustrative examples above, prior to configuring the test scenario, memory is allocated for the configuration struct by invoking, gn_config_calloc() and to free the allocated memory, gn_config_free() is called.</p>"},{"location":"theory/#test-configuration","title":"Test Configuration","text":"<p>As indicated previously, test configuration is driven through an opaque struct. The public members that are accessible to the user for the purpose of specifying either the waveform or the FFT or the analysis settings are shown in the table below. </p> Catgory Member Name Datatype Description Notes Waveform and FFT settings ttype ENUM Tone type Options: REAL_COSINE REAL_SINE COMPLEX_EXP npts size_t Num. of sample points in the waveform sample_rate double Sample Rate Units: samples/second tone_freq double* Tone frequency Units: Hertz tone_ampl double* Tone amplitude tone_phase double* Tone phase num_tones size_t Num. of tones fsr double ADC full-scale range Units: Volts qres int Quantization resolution Units: bits noise_rms double Noise RMS value code_format ENUM Code format of ADC/DAC codes Options: GnCodeFormatOffsetBinary GnCodeFormatTwosComplement nfft size_t FFT order fft_navg size_t Num. of FFT averages data_rate double Data rate Units: samples/second shift_freq double Shift frequency Units: Hertz win ENUM Window function Options: GnWindowBlackmanHarris GnWindowHann GnWindowNoWindow ramp_start double Start value of ramp ramp_stop double Stop value of ramp Fourier analysis settings ssb_fund int Single side bin - Fundamental ssb_fund int Single side bin - Fundamental max_harm_order int Max. order of harmonic NL analysis settings dnla_signal_type ENUM DNL analysis signal type Options: GnDnlSignalRamp GnDnlSignalTone inla_fit ENUM INL analysis fit Options: GnInlLineFitBestFit GnInlLineFitEndFit GnInlLineFitNoFit <p>As shown by this table, not all parameters are necessary in all use-cases. Consequently, each of the above struct members are accessible through gn_config_set_* functions. For instance, in order to configure sample rate, the function, gn_config_set_sample_rate would be used. Similarly for the other struct members. Additionally, the functions, gn_config_gen_tone, gn_config_gen_ramp, gn_config_quantize, gn_config_fft, and gn_config_fa can be used to configure a set of parameters that are needed in certain specific use-cases. Further details on the function signatures for each of these configuration functions can be found on the API reference page.</p> <p>The following table describes a few use-cases and the relevant members of the configuration struct that need to be set in order to generate a waveform or to perform the desired analysis using genalyzer.</p> Use-case gn_config members to configure Pre-requite function call Function call Generate single-/multi-tone waveform <ul><li>ttype</li><li>npts</li><li>sample_rate</li><li>num_tones</li><li>tone_freq</li><li>tone_ampl</li><li>tone_phase</li></ul> gn_config_gen_tone() gn_gen_tone() Generate ramp waveform <ul><li>npts</li><li>ramp_start</li><li>ramp_stop</li></ul> gn_config_gen_ramp()1 gn_gen_ramp() Quantize waveform <ul><li>npts</li><li>fsr</li><li>qres</li><li>noise_rms</li></ul> gn_config_quantize()2 gn_quantize() Compute FFT <ul><li>npts</li><li>qres</li><li>fft_navg</li><li>nfft</li><li>win</li></ul> gn_config_fft()2 gn_fftz() Compute histogram <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2 gn_histz() Compute DNL <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2 gn_dnlz() Compute INL <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2,3 gn_inlz() Do Fourier analysis <ul><li>nfft</li></ul> gn_config_fa()4 gn_get_fa_single_result() or gn_get_fa_results() Do waveform analysis <ul><li>npts</li></ul> gn_config_set_npts() gn_get_wfa_results() Do histogram analysis <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2 gn_get_ha_results() Do DNL analysis <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2 gn_get_dnla_results() Do INL analysis <ul><li>npts</li><li>qres</li></ul> gn_config_histz_nla()2 gn_get_inla_results() <p>1noise_rms=0.0 is used. It can be overridden by calling gn_config_set_noise_rms() prior to calling gn_gen_ramp().</p> <p>2code_format=GnCodeFormatTwosComplement is used. It can be overridden by calling gn_config_set_code_format() prior to calling the corresponding pre-requisite function call.</p> <p>3inla_fit=GnInlLineFitBestFit is used. It can be overridden by calling gn_config_set_inla_fit() prior to calling gn_config_histz_nla().</p> <p>4The following default settings are used.<ul><li>ssb_fund = 0</li><li>ssb_rest = 0</li><li>max_harm_order = 3</li><li>axis_type=GnFreqAxisTypeDcCenter</li></ul> They can be overridden by calling gn_config_set_ssb_fund(), gn_config_set_ssb_rest(), gn_config_set_max_harm_order(), gn_config_set_axis_type() prior to calling gn_get_fa_results() or gn_get_fa_single_result().</p> <p>Note that for certain use-cases, the pre-requisite function calls need not be invoked. For instance, given an analog waveform, if the user intends to quantize it and then compute the histogram, calling gn_config_quantize() will set the gn_config struct parameters needed prior to invoking gn_histz().</p> <p>As indicated in the overall skelton C-script that interfaces with genalyzer, the first stage involves configuring an opaque struct that is provided to the users in order to describe the measurement scenario. Here, users can select between three <code>config_*_meas()</code> function calls in order to select between tone-, ramp- and noise-based performance metric calculations. The opaque struct maintains the state of the test scenario and is passed to the waveform generation and performance metric computation stages subsequently.</p> <p>Tone-based Test Configuration In tone-based test configuration, <code>config_tone_meas()</code> allows users to indicate test settings such as, number of tones, their frequencies, phases, scales, whether real sinusoidal or complex-exponential waveforms are to be generated, the sample-rate, full-scale range of the converter, its resolution etc. Similarly, users can indicate whether the data that will be loaded in the second stage is time-series data or interleaved FFT samples. Moreover, in data-capture scenario i.e., when FFT data is provided to Genalyzer in the second step, the tone frequency, scale and phase information is not required. This test configuration is used for measurements such as SFDR, THD, TIL etc.</p> <p>An example of the <code>config_tone_meas()</code> function call is shown by the following example. <pre><code>// configuration\nconfig_tone_meas(&amp;c,\ndomain_wf,\ntype_wf,\nnfft, // FFT order\nnavg, // # of FFTs averaged\nfs, // sample rate\nfsr, // full-scale range\n0, // ADC resolution: unused configuration setting\nfreq, // tone frequency, # of array elements = num_tones\nscale, // tone scale, # of array elements = num_tones\nphase, // tone phase, # of array elements = num_tones\nnum_tones, // # of tones\nfalse,\nfalse,\nfalse\n);\n</code></pre></p> <p>Ramp-based Test Configuration In ramp-based test configuration, <code>config_ramp_meas()</code> allows users to indicate test settings such as, the starting and ending values of the ramp waveform in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used in non-linearity based measurements.</p> <p>An example of the <code>config_ramp_meas()</code> function call is shown by the following example. <pre><code>// configuration\nconfig_ramp_nl_meas(&amp;c,\nnpts, // # of data points\nfs, // sample rate\nfsr, // full-scale range\nres, // ADC resolution: unused configuration setting\nstart,\nstop,\n0.0\n);\n</code></pre></p> <p>Noise-based Test Configuration In noise-based test configuration, <code>config_noise_meas()</code> allows users to indicate test settings such as, the noise power level in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used for computing noise spectral density. </p> <p>An example of the <code>config_noise_meas()</code> function call is shown by the following example. <pre><code>// configuration\nconfig_noise_meas(&amp;c,\nCOMPLEX_NOISE,\nnfft,\nnavg,\nfs,\nfsr,\nres,\nnoise_pwr_lvl,\nupdate_fsample,\nupdate_fdata,\nupdate_fshift);\n</code></pre></p>"},{"location":"theory/#waveform-generation","title":"Waveform Generation","text":"<p>The second step, as shown previously, involves either generating the waveform and quantizing it or loading the waveform from a file. The following options are currently supported.</p> <ul> <li>cosine/sine and complex exponential waveforms of arbitrary frequency and sample rate</li> <li>ramp waveform</li> <li>Gaussian noise waveform of desired noise power spectral density level</li> </ul> <p>In all three cases, the waveform generation functions take two arguments, the opaque configuration struct that has been populated in the first step and a double pointer that will contain the analog waveform generated. The subsequent call to <code>quantize()</code> takes the configuration struct, the analog input waveform and the output quantized waveform obtained from quantizeing the analog waveform based on the resolution contained in the configuration struct.</p> <p>Alternatively, if data is loaded from a file, the configuration struct generated in the first stage will serve as a descriptor of that data. Note that indicating whether time or frequency data is loaded is indicated simply by an argument to the <code>config_tone_meas()</code> call in the first step. <pre><code>#include &lt;stdbool.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"genalyzer_cwrapper.h\"\n\nint main(int argc, char *argv[]) {  // opaque config struct that will contain config settings\n// config c = NULL;\n\n/* configuration */\n// config_tone_meas(&amp;c, FREQ, ...);\n// config_tone_meas(&amp;c, TIME,...);\n\n/* load waveform generation*/\n// read_file_to_array(...);\n\n/* compute metrics */\n// fsnr_val = metric(..., \"FSNR\");\n\nreturn 0;\n}\n</code></pre></p>"},{"location":"theory/#performance-metric-computation","title":"Performance Metric Computation","text":"<p>The final stage involves simply computing the desired performance metric. Metric computation is done by a call to <code>metric()</code> where, the last argument is one of: </p> <ul> <li><code>\"FSNR\"</code></li> <li><code>\"NSD\"</code></li> <li><code>\"SFDR\"</code></li> <li><code>\"SINAD\"</code></li> <li><code>\"SNR\"</code></li> <li><code>\"TD\"</code></li> <li><code>\"THD\"</code></li> <li><code>\"TIL</code></li> </ul> <p>Again, the test configuration contained in the opaque struct obtained from the first step is helpful in determinging whether the </p>"},{"location":"using_genalyzer/","title":"Using Genalyzer","text":"<p>As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages:</p> <ul> <li>Test Configuration</li> <li>Waveform Generation</li> <li>Metric Computation</li> </ul> <p>In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be </p> <ul> <li>Test Configuration</li> <li>Waveform Loading</li> <li>Metric Computation</li> </ul> <p>That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. ``` c</p>"},{"location":"using_genalyzer/#include-cgenalyzerh","title":"include \"cgenalyzer.h\"","text":"<p>int main(int argc, char *argv[]) {   // opaque config struct that will contain config settings   // config c = NULL;</p> <p>/ configuration /   // config_tone_meas(...);</p> <p>/ waveform generation and quantize /   // gen_tone(...);   // quantize(...);</p> <p>/ compute metrics /   // fsnr_val = metric(..., \"FSNR\");</p> <p>return 0; }```</p> <p>.. literalinclude:: general_example_skelton1.c     :language: C</p> <p>Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example.</p> <p>.. literalinclude:: general_example_skelton2.c     :language: C</p> <p>.. include:: 02a_test_configuration.rst .. include:: 02b_waveform_generation.rst .. include:: 02c_perf_metric_computation.rst</p>"}]}