{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"genalyzer Library for data converter and general sampled data analysis. Genalyzer is a C++ library that facilitates the computation of commonly used data-converter RF performance metrics in a standards-complaint manner. Genalyzer supports generation of waveforms for characterizing data-converters as well as the computation of performance metrics given the time- or frequency-domain response of data-converters to such waveforms. In other words, users not only have the option of selecting whether or not to opt for waveform generation to characterize data-convereters, but are also able to utilize time-series data or FFT of samples captured from a data-convereter to directly compute the desired performance metrics. Thus, Genalyzer can support a simulation-only scenario or a data-capture scenario. In the first case, the response of a data-converter is simulated given its specifications, in order to compute the expected performance metrics. In the second case, the response of a data-converter is available for Genalyzer to process in the form of a text or binary file. Genalyzer facilitates the computation of common data converter performance metrics in a standards-complaint manner. The terminology and definitions for various common performance metrics are adopted from the IEEE Standard for Terminology and Test Methods for Analog-to-Digital Converters (IEEE 1241-2010) and the IEEE Standard for Terminology and Test Methods of Digital-to-Analog Converter Devices (IEEE 1658-2011) both published by Instrumentation and Measurement/Waveform Generation, Measurement, and Analysis - Technical Committee 10 (IM/WM&A - TC10). Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#genalyzer","text":"Library for data converter and general sampled data analysis. Genalyzer is a C++ library that facilitates the computation of commonly used data-converter RF performance metrics in a standards-complaint manner. Genalyzer supports generation of waveforms for characterizing data-converters as well as the computation of performance metrics given the time- or frequency-domain response of data-converters to such waveforms. In other words, users not only have the option of selecting whether or not to opt for waveform generation to characterize data-convereters, but are also able to utilize time-series data or FFT of samples captured from a data-convereter to directly compute the desired performance metrics. Thus, Genalyzer can support a simulation-only scenario or a data-capture scenario. In the first case, the response of a data-converter is simulated given its specifications, in order to compute the expected performance metrics. In the second case, the response of a data-converter is available for Genalyzer to process in the form of a text or binary file. Genalyzer facilitates the computation of common data converter performance metrics in a standards-complaint manner. The terminology and definitions for various common performance metrics are adopted from the IEEE Standard for Terminology and Test Methods for Analog-to-Digital Converters (IEEE 1241-2010) and the IEEE Standard for Terminology and Test Methods of Digital-to-Analog Converter Devices (IEEE 1658-2011) both published by Instrumentation and Measurement/Waveform Generation, Measurement, and Analysis - Technical Committee 10 (IM/WM&A - TC10).","title":"genalyzer"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cgenalyzer_8h/","text":"Functions Name Description gn_config_free free memory for configuration struct gn_config_set_ttype set configuration struct member: tone_type gn_config_set_npts set configuration struct member: npts gn_config_get_npts get configuration struct member: npts gn_config_set_sample_rate set configuration struct member: sample_rate gn_config_get_sample_rate get configuration struct member: sample_rate gn_config_set_data_rate set configuration struct member: data_rate gn_config_set_shift_freq set configuration struct member: shift_freq gn_config_set_num_tones set configuration struct member: num_tones gn_config_set_tone_freq set configuration struct member: tone_freq gn_config_set_tone_ampl set configuration struct member: tone_ampl gn_config_set_tone_phase set configuration struct member: tone_phase gn_config_set_fsr set configuration struct member: fsr gn_config_set_qres set configuration struct member: qres gn_config_set_noise_rms set configuration struct member: noise_rms gn_config_set_code_format set configuration struct member: code_format gn_config_set_nfft set configuration struct member: nfft gn_config_get_nfft get configuration struct member: nfft gn_config_set_fft_navg set configuration struct member: navg gn_config_set_win set configuration struct member: win gn_config_set_ssb_fund set configuration struct member: ssb_fund gn_config_set_ssb_rest set configuration struct member: ssb_rest gn_config_set_max_harm_order set configuration struct member: max_harm_order gn_config_set_dnla_signal_type set configuration struct member: dnla_signal_type gn_config_set_inla_fit set configuration struct member: inla_fit gn_config_set_ramp_start set configuration struct member: ramp_start gn_config_set_ramp_stop set configuration struct member: ramp_stop gn_config_get_code_density_size get configuration struct member: _code_density_size gn_config_gen_tone Configure tone parameters to be used in measurement. gn_config_gen_ramp Configure tone parameters to be used in measurement. gn_config_quantize Configure quantization parameters to be used in measurement. gn_config_histz_nla Configure parameters to compute histogram. gn_config_fftz Configure FFT parameters. gn_config_fa Generate sinusoidal tone based on supplied configuration. gn_gen_ramp Generate ramp based on supplied configuration. gn_gen_real_tone Generate sinusoidal tone based on supplied configuration. gn_gen_complex_tone Generate sinusoidal tone based on supplied configuration. gn_quantize Quantize waveform based on supplied configuration. gn_fftz Compute FFT of quantized input waveform. gn_histz Compute histogram of quantized waveform. gn_dnlz Compute histogram of quantized waveform. gn_inlz Compute histogram of quantized waveform. gn_get_wfa_results Do waveform analysis and all get results. gn_get_ha_results Do histogram analysis and get results. gn_get_dnla_results Do DNL analysis and get results. gn_get_inla_results Do INL analysis and get results. gn_get_fa_single_result Do Fourier analysis and get a single result. gn_get_fa_results Do Fourier analysis and all get results. Types Name enum tone_type typedef struct gn_config_private * gn_config typedef enum tone_type tone_type Library Functions function gn_config_free int gn_config_free ( gn_config * c ) free memory for configuration struct Parameter Description c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_ttype int gn_config_set_ttype ( tone_type ttype , gn_config * c ) set configuration struct member: tone_type Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_npts int gn_config_set_npts ( size_t npts , gn_config * c ) set configuration struct member: npts Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_get_npts int gn_config_get_npts ( size_t * npts , gn_config * c ) get configuration struct member: npts Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_sample_rate int gn_config_set_sample_rate ( double sample_rate , gn_config * c ) set configuration struct member: sample_rate Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_get_sample_rate int gn_config_get_sample_rate ( double * sample_rate , gn_config * c ) get configuration struct member: sample_rate Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_data_rate int gn_config_set_data_rate ( double data_rate , gn_config * c ) set configuration struct member: data_rate Parameter Description data_rate Input data rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_shift_freq int gn_config_set_shift_freq ( double shift_freq , gn_config * c ) set configuration struct member: shift_freq Parameter Description shift_freq Shift frequency of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_num_tones int gn_config_set_num_tones ( size_t num_tones , gn_config * c ) set configuration struct member: num_tones Parameter Description num_tones Number of tones to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_tone_freq int gn_config_set_tone_freq ( double * tone_freq , gn_config * c ) set configuration struct member: tone_freq Parameter Description tone_freq Input array of tone frequencies to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_tone_ampl int gn_config_set_tone_ampl ( double * tone_ampl , gn_config * c ) set configuration struct member: tone_ampl Parameter Description tone_ampl Input array of tone scales to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_tone_phase int gn_config_set_tone_phase ( double * tone_phase , gn_config * c ) set configuration struct member: tone_phase Parameter Description tone_phase Input array of tone phases to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_fsr int gn_config_set_fsr ( double fsr , gn_config * c ) set configuration struct member: fsr Parameter Description fsr Full-scale range of the waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_qres int gn_config_set_qres ( int qres , gn_config * c ) set configuration struct member: qres Parameter Description qres Quantization resolution c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_noise_rms int gn_config_set_noise_rms ( double noise_rms , gn_config * c ) set configuration struct member: noise_rms Parameter Description qres Quantization noise c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_code_format int gn_config_set_code_format ( GnCodeFormat code_format , gn_config * c ) set configuration struct member: code_format Parameter Description code_format Code format of data c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_nfft int gn_config_set_nfft ( size_t nfft , gn_config * c ) set configuration struct member: nfft Parameter Description nfft FFT order c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_get_nfft int gn_config_get_nfft ( size_t * nfft , gn_config * c ) get configuration struct member: nfft Parameter Description nfft FFT order c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_fft_navg int gn_config_set_fft_navg ( size_t fft_navg , gn_config * c ) set configuration struct member: navg Parameter Description navg Num. of FFTs to average c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_win int gn_config_set_win ( GnWindow win , gn_config * c ) set configuration struct member: win Parameter Description win Window function used c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_ssb_fund int gn_config_set_ssb_fund ( int ssb_fund , gn_config * c ) set configuration struct member: ssb_fund Parameter Description ssb_fund Single side bin fundamental c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_ssb_rest int gn_config_set_ssb_rest ( int ssb_rest , gn_config * c ) set configuration struct member: ssb_rest Parameter Description ssb_rest Single side bins rest c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_max_harm_order int gn_config_set_max_harm_order ( int max_harm_order , gn_config * c ) set configuration struct member: max_harm_order Parameter Description max_harm_order Max order of harmonic c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_dnla_signal_type int gn_config_set_dnla_signal_type ( GnDnlSignal dnla_signal_type , gn_config * c ) set configuration struct member: dnla_signal_type Parameter Description dnla_signal_type DNL analysis signal type c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_inla_fit int gn_config_set_inla_fit ( GnInlLineFit inla_fit , gn_config * c ) set configuration struct member: inla_fit Parameter Description inla_fit INL analysis line fit c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_ramp_start int gn_config_set_ramp_start ( double ramp_start , gn_config * c ) set configuration struct member: ramp_start Parameter Description ramp_start start value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_set_ramp_stop int gn_config_set_ramp_stop ( double ramp_stop , gn_config * c ) set configuration struct member: ramp_stop Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_get_code_density_size int gn_config_get_code_density_size ( size_t * code_density_size , gn_config * c ) get configuration struct member: _code_density_size Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise function gn_config_gen_tone int gn_config_gen_tone ( tone_type ttype , size_t npts , double sample_rate , size_t num_tones , double * tone_freq , double * tone_ampl , double * tone_phase , gn_config * c ) Configure tone parameters to be used in measurement. Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP npts Number of sample points in the generated waveform sample_rate Input Sample rate of the data converter num_tones Number of tones to generate tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate c Configuration struct containing tone parameters Return : 0 on success, non-zero otherwise function gn_config_gen_ramp int gn_config_gen_ramp ( size_t npts , double ramp_start , double ramp_stop , gn_config * c ) Configure tone parameters to be used in measurement. Parameter Description npts Number of sample points in the generated waveform ramp_start Input start value of ramp ramp_stop Input stop value of ramp c Configuration struct containing ramp parameters Return : 0 on success, non-zero otherwise function gn_config_quantize int gn_config_quantize ( size_t npts , double fsr , int qres , double qnoise , gn_config * c ) Configure quantization parameters to be used in measurement. Parameter Description npts Number of sample points in the generated waveform fsr Full-scale range of the waveform qres Quantization resolution qnoise Quantization noise c Configuration structure Return : 0 on success, non-zero otherwise function gn_config_histz_nla int gn_config_histz_nla ( size_t npts , int qres , gn_config * c ) Configure parameters to compute histogram. Parameter Description npts Number of sample points in the generated waveform qres Quantization resolution c Configuration structure Return : 0 on success, non-zero otherwise function gn_config_fftz int gn_config_fftz ( size_t npts , int qres , size_t navg , size_t nfft , GnWindow win , gn_config * c ) Configure FFT parameters. Return : 0 on success, non-zero otherwise function gn_config_fa int gn_config_fa ( double fixed_tone_freq , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Return : 0 on success, non-zero otherwise function gn_gen_ramp int gn_gen_ramp ( double ** out , gn_config * c ) Generate ramp based on supplied configuration. Parameter Description out Output array of ramp generated c Configuration structure of test and waveform to generate function gn_gen_real_tone int gn_gen_real_tone ( double ** out , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Parameter Description out Output array of generated tone c Configuration structure containing test parameters Return : 0 on success, non-zero otherwise function gn_gen_complex_tone int gn_gen_complex_tone ( double ** outi , double ** outq , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Parameter Description outi In-phase output array of generated tone outq Quadrature output array of generated tone c Configuration structure containing test parameters Return : 0 on success, non-zero otherwise function gn_quantize int gn_quantize ( int32_t ** out , const double * in , gn_config * c ) Quantize waveform based on supplied configuration. Return : 0 on success, non-zero otherwise function gn_fftz int gn_fftz ( double ** out , const int32_t * in_i , const int32_t * in_q , gn_config * c ) Compute FFT of quantized input waveform. Return : 0 on success, non-zero otherwise function gn_histz int gn_histz ( uint64_t ** hist , size_t * hist_len , const int32_t * qwf , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise function gn_dnlz int gn_dnlz ( double ** dnl , size_t * dnl_len , const uint64_t * hist , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise function gn_inlz int gn_inlz ( double ** inl , size_t * inl_len , const double * dnl , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise function gn_get_wfa_results int gn_get_wfa_results ( char *** rkeys , double ** rvalues , size_t * results_size , const int32_t * qwf , gn_config * c ) Do waveform analysis and all get results. Return : 0 on success, non-zero otherwise function gn_get_ha_results int gn_get_ha_results ( char *** rkeys , double ** rvalues , size_t * results_size , const uint64_t * hist , gn_config * c ) Do histogram analysis and get results. Return : 0 on success, non-zero otherwise function gn_get_dnla_results int gn_get_dnla_results ( char *** rkeys , double ** rvalues , size_t * results_size , const double * dnl , gn_config * c ) Do DNL analysis and get results. Return : 0 on success, non-zero otherwise function gn_get_inla_results int gn_get_inla_results ( char *** rkeys , double ** rvalues , size_t * results_size , const double * inl , gn_config * c ) Do INL analysis and get results. Return : 0 on success, non-zero otherwise function gn_get_fa_single_result int gn_get_fa_single_result ( double * rvalue , const char * metric_name , double * fft_ilv , gn_config * c ) Do Fourier analysis and get a single result. Return : 0 on success, non-zero otherwise function gn_get_fa_results int gn_get_fa_results ( char *** rkeys , double ** rvalues , size_t * results_size , double * fft_ilv , gn_config * c ) Do Fourier analysis and all get results. Return : 0 on success, non-zero otherwise Library Types enum tone_type Enumerator Value Description REAL_COSINE REAL_SINE COMPLEX_EXP typedef gn_config typedef struct gn_config_private * gn_config ; typedef tone_type typedef enum tone_type tone_type ; Updated on 2022-10-21 at 17:02:20 +0000","title":"API Reference"},{"location":"cgenalyzer_8h/#functions","text":"Name Description gn_config_free free memory for configuration struct gn_config_set_ttype set configuration struct member: tone_type gn_config_set_npts set configuration struct member: npts gn_config_get_npts get configuration struct member: npts gn_config_set_sample_rate set configuration struct member: sample_rate gn_config_get_sample_rate get configuration struct member: sample_rate gn_config_set_data_rate set configuration struct member: data_rate gn_config_set_shift_freq set configuration struct member: shift_freq gn_config_set_num_tones set configuration struct member: num_tones gn_config_set_tone_freq set configuration struct member: tone_freq gn_config_set_tone_ampl set configuration struct member: tone_ampl gn_config_set_tone_phase set configuration struct member: tone_phase gn_config_set_fsr set configuration struct member: fsr gn_config_set_qres set configuration struct member: qres gn_config_set_noise_rms set configuration struct member: noise_rms gn_config_set_code_format set configuration struct member: code_format gn_config_set_nfft set configuration struct member: nfft gn_config_get_nfft get configuration struct member: nfft gn_config_set_fft_navg set configuration struct member: navg gn_config_set_win set configuration struct member: win gn_config_set_ssb_fund set configuration struct member: ssb_fund gn_config_set_ssb_rest set configuration struct member: ssb_rest gn_config_set_max_harm_order set configuration struct member: max_harm_order gn_config_set_dnla_signal_type set configuration struct member: dnla_signal_type gn_config_set_inla_fit set configuration struct member: inla_fit gn_config_set_ramp_start set configuration struct member: ramp_start gn_config_set_ramp_stop set configuration struct member: ramp_stop gn_config_get_code_density_size get configuration struct member: _code_density_size gn_config_gen_tone Configure tone parameters to be used in measurement. gn_config_gen_ramp Configure tone parameters to be used in measurement. gn_config_quantize Configure quantization parameters to be used in measurement. gn_config_histz_nla Configure parameters to compute histogram. gn_config_fftz Configure FFT parameters. gn_config_fa Generate sinusoidal tone based on supplied configuration. gn_gen_ramp Generate ramp based on supplied configuration. gn_gen_real_tone Generate sinusoidal tone based on supplied configuration. gn_gen_complex_tone Generate sinusoidal tone based on supplied configuration. gn_quantize Quantize waveform based on supplied configuration. gn_fftz Compute FFT of quantized input waveform. gn_histz Compute histogram of quantized waveform. gn_dnlz Compute histogram of quantized waveform. gn_inlz Compute histogram of quantized waveform. gn_get_wfa_results Do waveform analysis and all get results. gn_get_ha_results Do histogram analysis and get results. gn_get_dnla_results Do DNL analysis and get results. gn_get_inla_results Do INL analysis and get results. gn_get_fa_single_result Do Fourier analysis and get a single result. gn_get_fa_results Do Fourier analysis and all get results.","title":"Functions"},{"location":"cgenalyzer_8h/#types","text":"Name enum tone_type typedef struct gn_config_private * gn_config typedef enum tone_type tone_type","title":"Types"},{"location":"cgenalyzer_8h/#library-functions","text":"","title":"Library Functions"},{"location":"cgenalyzer_8h/#function-gn_config_free","text":"int gn_config_free ( gn_config * c ) free memory for configuration struct Parameter Description c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_free"},{"location":"cgenalyzer_8h/#function-gn_config_set_ttype","text":"int gn_config_set_ttype ( tone_type ttype , gn_config * c ) set configuration struct member: tone_type Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_ttype"},{"location":"cgenalyzer_8h/#function-gn_config_set_npts","text":"int gn_config_set_npts ( size_t npts , gn_config * c ) set configuration struct member: npts Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_npts"},{"location":"cgenalyzer_8h/#function-gn_config_get_npts","text":"int gn_config_get_npts ( size_t * npts , gn_config * c ) get configuration struct member: npts Parameter Description npts Number of sample points in the generated waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_get_npts"},{"location":"cgenalyzer_8h/#function-gn_config_set_sample_rate","text":"int gn_config_set_sample_rate ( double sample_rate , gn_config * c ) set configuration struct member: sample_rate Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_sample_rate"},{"location":"cgenalyzer_8h/#function-gn_config_get_sample_rate","text":"int gn_config_get_sample_rate ( double * sample_rate , gn_config * c ) get configuration struct member: sample_rate Parameter Description sample_rate Input Sample rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_get_sample_rate"},{"location":"cgenalyzer_8h/#function-gn_config_set_data_rate","text":"int gn_config_set_data_rate ( double data_rate , gn_config * c ) set configuration struct member: data_rate Parameter Description data_rate Input data rate of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_data_rate"},{"location":"cgenalyzer_8h/#function-gn_config_set_shift_freq","text":"int gn_config_set_shift_freq ( double shift_freq , gn_config * c ) set configuration struct member: shift_freq Parameter Description shift_freq Shift frequency of the data converter c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_shift_freq"},{"location":"cgenalyzer_8h/#function-gn_config_set_num_tones","text":"int gn_config_set_num_tones ( size_t num_tones , gn_config * c ) set configuration struct member: num_tones Parameter Description num_tones Number of tones to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_num_tones"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_freq","text":"int gn_config_set_tone_freq ( double * tone_freq , gn_config * c ) set configuration struct member: tone_freq Parameter Description tone_freq Input array of tone frequencies to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_tone_freq"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_ampl","text":"int gn_config_set_tone_ampl ( double * tone_ampl , gn_config * c ) set configuration struct member: tone_ampl Parameter Description tone_ampl Input array of tone scales to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_tone_ampl"},{"location":"cgenalyzer_8h/#function-gn_config_set_tone_phase","text":"int gn_config_set_tone_phase ( double * tone_phase , gn_config * c ) set configuration struct member: tone_phase Parameter Description tone_phase Input array of tone phases to generate c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_tone_phase"},{"location":"cgenalyzer_8h/#function-gn_config_set_fsr","text":"int gn_config_set_fsr ( double fsr , gn_config * c ) set configuration struct member: fsr Parameter Description fsr Full-scale range of the waveform c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_fsr"},{"location":"cgenalyzer_8h/#function-gn_config_set_qres","text":"int gn_config_set_qres ( int qres , gn_config * c ) set configuration struct member: qres Parameter Description qres Quantization resolution c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_qres"},{"location":"cgenalyzer_8h/#function-gn_config_set_noise_rms","text":"int gn_config_set_noise_rms ( double noise_rms , gn_config * c ) set configuration struct member: noise_rms Parameter Description qres Quantization noise c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_noise_rms"},{"location":"cgenalyzer_8h/#function-gn_config_set_code_format","text":"int gn_config_set_code_format ( GnCodeFormat code_format , gn_config * c ) set configuration struct member: code_format Parameter Description code_format Code format of data c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_code_format"},{"location":"cgenalyzer_8h/#function-gn_config_set_nfft","text":"int gn_config_set_nfft ( size_t nfft , gn_config * c ) set configuration struct member: nfft Parameter Description nfft FFT order c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_nfft"},{"location":"cgenalyzer_8h/#function-gn_config_get_nfft","text":"int gn_config_get_nfft ( size_t * nfft , gn_config * c ) get configuration struct member: nfft Parameter Description nfft FFT order c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_get_nfft"},{"location":"cgenalyzer_8h/#function-gn_config_set_fft_navg","text":"int gn_config_set_fft_navg ( size_t fft_navg , gn_config * c ) set configuration struct member: navg Parameter Description navg Num. of FFTs to average c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_fft_navg"},{"location":"cgenalyzer_8h/#function-gn_config_set_win","text":"int gn_config_set_win ( GnWindow win , gn_config * c ) set configuration struct member: win Parameter Description win Window function used c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_win"},{"location":"cgenalyzer_8h/#function-gn_config_set_ssb_fund","text":"int gn_config_set_ssb_fund ( int ssb_fund , gn_config * c ) set configuration struct member: ssb_fund Parameter Description ssb_fund Single side bin fundamental c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_ssb_fund"},{"location":"cgenalyzer_8h/#function-gn_config_set_ssb_rest","text":"int gn_config_set_ssb_rest ( int ssb_rest , gn_config * c ) set configuration struct member: ssb_rest Parameter Description ssb_rest Single side bins rest c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_ssb_rest"},{"location":"cgenalyzer_8h/#function-gn_config_set_max_harm_order","text":"int gn_config_set_max_harm_order ( int max_harm_order , gn_config * c ) set configuration struct member: max_harm_order Parameter Description max_harm_order Max order of harmonic c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_max_harm_order"},{"location":"cgenalyzer_8h/#function-gn_config_set_dnla_signal_type","text":"int gn_config_set_dnla_signal_type ( GnDnlSignal dnla_signal_type , gn_config * c ) set configuration struct member: dnla_signal_type Parameter Description dnla_signal_type DNL analysis signal type c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_dnla_signal_type"},{"location":"cgenalyzer_8h/#function-gn_config_set_inla_fit","text":"int gn_config_set_inla_fit ( GnInlLineFit inla_fit , gn_config * c ) set configuration struct member: inla_fit Parameter Description inla_fit INL analysis line fit c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_inla_fit"},{"location":"cgenalyzer_8h/#function-gn_config_set_ramp_start","text":"int gn_config_set_ramp_start ( double ramp_start , gn_config * c ) set configuration struct member: ramp_start Parameter Description ramp_start start value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_ramp_start"},{"location":"cgenalyzer_8h/#function-gn_config_set_ramp_stop","text":"int gn_config_set_ramp_stop ( double ramp_stop , gn_config * c ) set configuration struct member: ramp_stop Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_set_ramp_stop"},{"location":"cgenalyzer_8h/#function-gn_config_get_code_density_size","text":"int gn_config_get_code_density_size ( size_t * code_density_size , gn_config * c ) get configuration struct member: _code_density_size Parameter Description ramp_stop stop value of ramp c genalyzer Configuration struct Return : 0 on success, non-zero otherwise","title":"function gn_config_get_code_density_size"},{"location":"cgenalyzer_8h/#function-gn_config_gen_tone","text":"int gn_config_gen_tone ( tone_type ttype , size_t npts , double sample_rate , size_t num_tones , double * tone_freq , double * tone_ampl , double * tone_phase , gn_config * c ) Configure tone parameters to be used in measurement. Parameter Description ttype ENUM value to indicate input tone type. Options: REAL_COSINE, REAL_SINE, COMPLEX_EXP npts Number of sample points in the generated waveform sample_rate Input Sample rate of the data converter num_tones Number of tones to generate tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate c Configuration struct containing tone parameters Return : 0 on success, non-zero otherwise","title":"function gn_config_gen_tone"},{"location":"cgenalyzer_8h/#function-gn_config_gen_ramp","text":"int gn_config_gen_ramp ( size_t npts , double ramp_start , double ramp_stop , gn_config * c ) Configure tone parameters to be used in measurement. Parameter Description npts Number of sample points in the generated waveform ramp_start Input start value of ramp ramp_stop Input stop value of ramp c Configuration struct containing ramp parameters Return : 0 on success, non-zero otherwise","title":"function gn_config_gen_ramp"},{"location":"cgenalyzer_8h/#function-gn_config_quantize","text":"int gn_config_quantize ( size_t npts , double fsr , int qres , double qnoise , gn_config * c ) Configure quantization parameters to be used in measurement. Parameter Description npts Number of sample points in the generated waveform fsr Full-scale range of the waveform qres Quantization resolution qnoise Quantization noise c Configuration structure Return : 0 on success, non-zero otherwise","title":"function gn_config_quantize"},{"location":"cgenalyzer_8h/#function-gn_config_histz_nla","text":"int gn_config_histz_nla ( size_t npts , int qres , gn_config * c ) Configure parameters to compute histogram. Parameter Description npts Number of sample points in the generated waveform qres Quantization resolution c Configuration structure Return : 0 on success, non-zero otherwise","title":"function gn_config_histz_nla"},{"location":"cgenalyzer_8h/#function-gn_config_fftz","text":"int gn_config_fftz ( size_t npts , int qres , size_t navg , size_t nfft , GnWindow win , gn_config * c ) Configure FFT parameters. Return : 0 on success, non-zero otherwise","title":"function gn_config_fftz"},{"location":"cgenalyzer_8h/#function-gn_config_fa","text":"int gn_config_fa ( double fixed_tone_freq , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Return : 0 on success, non-zero otherwise","title":"function gn_config_fa"},{"location":"cgenalyzer_8h/#function-gn_gen_ramp","text":"int gn_gen_ramp ( double ** out , gn_config * c ) Generate ramp based on supplied configuration. Parameter Description out Output array of ramp generated c Configuration structure of test and waveform to generate","title":"function gn_gen_ramp"},{"location":"cgenalyzer_8h/#function-gn_gen_real_tone","text":"int gn_gen_real_tone ( double ** out , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Parameter Description out Output array of generated tone c Configuration structure containing test parameters Return : 0 on success, non-zero otherwise","title":"function gn_gen_real_tone"},{"location":"cgenalyzer_8h/#function-gn_gen_complex_tone","text":"int gn_gen_complex_tone ( double ** outi , double ** outq , gn_config * c ) Generate sinusoidal tone based on supplied configuration. Parameter Description outi In-phase output array of generated tone outq Quadrature output array of generated tone c Configuration structure containing test parameters Return : 0 on success, non-zero otherwise","title":"function gn_gen_complex_tone"},{"location":"cgenalyzer_8h/#function-gn_quantize","text":"int gn_quantize ( int32_t ** out , const double * in , gn_config * c ) Quantize waveform based on supplied configuration. Return : 0 on success, non-zero otherwise","title":"function gn_quantize"},{"location":"cgenalyzer_8h/#function-gn_fftz","text":"int gn_fftz ( double ** out , const int32_t * in_i , const int32_t * in_q , gn_config * c ) Compute FFT of quantized input waveform. Return : 0 on success, non-zero otherwise","title":"function gn_fftz"},{"location":"cgenalyzer_8h/#function-gn_histz","text":"int gn_histz ( uint64_t ** hist , size_t * hist_len , const int32_t * qwf , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise","title":"function gn_histz"},{"location":"cgenalyzer_8h/#function-gn_dnlz","text":"int gn_dnlz ( double ** dnl , size_t * dnl_len , const uint64_t * hist , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise","title":"function gn_dnlz"},{"location":"cgenalyzer_8h/#function-gn_inlz","text":"int gn_inlz ( double ** inl , size_t * inl_len , const double * dnl , gn_config * c ) Compute histogram of quantized waveform. Return : 0 on success, non-zero otherwise","title":"function gn_inlz"},{"location":"cgenalyzer_8h/#function-gn_get_wfa_results","text":"int gn_get_wfa_results ( char *** rkeys , double ** rvalues , size_t * results_size , const int32_t * qwf , gn_config * c ) Do waveform analysis and all get results. Return : 0 on success, non-zero otherwise","title":"function gn_get_wfa_results"},{"location":"cgenalyzer_8h/#function-gn_get_ha_results","text":"int gn_get_ha_results ( char *** rkeys , double ** rvalues , size_t * results_size , const uint64_t * hist , gn_config * c ) Do histogram analysis and get results. Return : 0 on success, non-zero otherwise","title":"function gn_get_ha_results"},{"location":"cgenalyzer_8h/#function-gn_get_dnla_results","text":"int gn_get_dnla_results ( char *** rkeys , double ** rvalues , size_t * results_size , const double * dnl , gn_config * c ) Do DNL analysis and get results. Return : 0 on success, non-zero otherwise","title":"function gn_get_dnla_results"},{"location":"cgenalyzer_8h/#function-gn_get_inla_results","text":"int gn_get_inla_results ( char *** rkeys , double ** rvalues , size_t * results_size , const double * inl , gn_config * c ) Do INL analysis and get results. Return : 0 on success, non-zero otherwise","title":"function gn_get_inla_results"},{"location":"cgenalyzer_8h/#function-gn_get_fa_single_result","text":"int gn_get_fa_single_result ( double * rvalue , const char * metric_name , double * fft_ilv , gn_config * c ) Do Fourier analysis and get a single result. Return : 0 on success, non-zero otherwise","title":"function gn_get_fa_single_result"},{"location":"cgenalyzer_8h/#function-gn_get_fa_results","text":"int gn_get_fa_results ( char *** rkeys , double ** rvalues , size_t * results_size , double * fft_ilv , gn_config * c ) Do Fourier analysis and all get results. Return : 0 on success, non-zero otherwise","title":"function gn_get_fa_results"},{"location":"cgenalyzer_8h/#library-types","text":"","title":"Library Types"},{"location":"cgenalyzer_8h/#enum-tone_type","text":"Enumerator Value Description REAL_COSINE REAL_SINE COMPLEX_EXP","title":"enum tone_type"},{"location":"cgenalyzer_8h/#typedef-gn_config","text":"typedef struct gn_config_private * gn_config ;","title":"typedef gn_config"},{"location":"cgenalyzer_8h/#typedef-tone_type","text":"typedef enum tone_type tone_type ; Updated on 2022-10-21 at 17:02:20 +0000","title":"typedef tone_type"},{"location":"examples/","text":"Examples Fourier Analysis In the following working example, data from an ADALM-PLUTO is used to perform a Fourier analysis as shown below. Note that in the following example, it is assumed that the data is available in the form of a json file. It can be replaced by any other means of loading this data. C Python #include \"cgenalyzer.h\" #include \"../tests/test_genalyzer.h\" #include <stdlib.h> int main ( int argc , const char * argv []) { // read test waveform filename const char * test_filename = \"../tests/test_vectors/test_Pluto_DDS_data_1658159639196.json\" ; int err_code ; int32_t * ref_qwfi , * ref_qwfq ; double * fft_out ; size_t results_size ; char ** rkeys ; double * rvalues , sfdr ; // read parameters tone_type ttype ; int qres ; unsigned long long npts , navg , nfft , tmp_win , num_tones ; double * freq ; GnWindow win ; err_code = read_scalar_from_json_file ( test_filename , \"wf_type\" , ( void * )( & ttype ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"qres\" , ( void * )( & qres ), INT32 ); err_code = read_scalar_from_json_file ( test_filename , \"npts\" , ( void * )( & npts ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"navg\" , ( void * )( & navg ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"nfft\" , ( void * )( & nfft ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"num_tones\" , ( void * )( & num_tones ), UINT64 ); freq = ( double * ) calloc ( num_tones , sizeof ( double )); if ( num_tones > 1 ) err_code = read_array_from_json_file ( test_filename , \"freq\" , freq , DOUBLE , num_tones ); else err_code = read_scalar_from_json_file ( test_filename , \"freq\" , ( void * )( freq ), DOUBLE ); err_code = read_scalar_from_json_file ( test_filename , \"win\" , ( void * )( & tmp_win ), UINT64 ); if ( tmp_win == 1 ) win = GnWindowBlackmanHarris ; else if ( tmp_win == 2 ) win = GnWindowHann ; else if ( tmp_win == 3 ) win = GnWindowNoWindow ; // read reference waveforms ref_qwfi = ( int32_t * ) malloc ( npts * sizeof ( int32_t )); err_code = read_array_from_json_file ( test_filename , \"test_vec_i\" , ref_qwfi , INT32 , npts ); ref_qwfq = ( int32_t * ) malloc ( npts * sizeof ( int32_t )); err_code = read_array_from_json_file ( test_filename , \"test_vec_q\" , ref_qwfq , INT32 , npts ); // configuration gn_config c = NULL ; err_code = gn_config_fftz ( npts , qres , navg , nfft , win , & c ); // FFT of waveform err_code = gn_fftz ( & fft_out , ref_qwfi , ref_qwfq , & c ); // Configure Fourier analysis err_code = gn_config_fa ( freq [ 0 ], & c ); err_code = gn_get_fa_results ( & rkeys , & rvalues , & results_size , fft_out , & c ); printf ( \" \\n All Fourier Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); printf ( \"SFDR - %20.6f \\n \" , sfdr ); // free memory free ( ref_qwfi ); free ( ref_qwfq ); free ( fft_out ); free ( rvalues ); for ( size_t i = 0 ; i < results_size ; ++ i ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , os , json , glob , pprint import matplotlib.pyplot as plt test_dir = os . path . join ( * [ \"..\" , \"..\" , \"..\" , \"tests\" , \"test_vectors\" ]) loc = os . path . dirname ( __file__ ) f = glob . glob ( os . path . join ( loc , test_dir , \"test_Pluto_DDS_data_1658159639196.json\" )) a = open ( f [ 0 ]) data = json . load ( a ) if data [ 'num_tones' ] == 1 : freq_list = [ data [ 'freq' ]] else : freq_list = data [ 'freq' ] qwfi = data [ 'test_vec_i' ] qwfi = [ int ( i ) for i in qwfi ] qwfq = data [ 'test_vec_q' ] qwfq = [ int ( i ) for i in qwfq ] # configure c = genalyzer . config_fftz ( data [ 'npts' ], data [ 'qres' ], data [ 'navg' ], data [ 'nfft' ], data [ 'win' ] - 1 ) genalyzer . config_fa ( freq_list [ 0 ], c ) # compute FFT fft_out_i , fft_out_q = genalyzer . fftz ( qwfi , qwfq , c ) fft_out = [ val for pair in zip ( fft_out_i , fft_out_q ) for val in pair ] # get all Fourier analysis results all_results = genalyzer . get_fa_results ( fft_out , c ) # get a single Fourier analysis result sfdr = genalyzer . get_fa_single_result ( \"sfdr\" , fft_out , c ) # display results pprint . pprint ( all_results ) print ( 'SFDR - ' , sfdr ) # free memory genalyzer . config_free ( c ) A summary of the most important results displayed and a brief explanation is as follows: Result Name Description fsnr Full-scale Signal-to-Noise Ratio snr Signal-to-Noise Ratio sinad Signal-to-Noise and Distortion Ratio sfdr Spurious Free Dynamic Range abn Analysis Band Noise Power nsd Noise Spectral Density carrierindex Index of carrier tone maxspurindex Index of max. spur tone ab_nbins # of bins in analysis band ab_rss Analysis band received signal strength hd_nbins # of bins in used in computing harmonic distortion hd_rss Harmonic distortion band received signal strength imd_nbins # of bins in used in computing inter-modulation distortion imd_rss Inter-modulation distortion band received signal strength thd_nbins # of bins in used in computing total harmonic distortion thd_rss Total harmonic distortion band received signal strength Waveform Analysis In the following working example, genalyzer is used to generate a cosine-tone waveform, then the effect of a data-converter on this waveform is simulated and a basic waveform analysis is performed as shown below. C Python #include \"cgenalyzer.h\" #include <stdlib.h> int main ( int argc , const char * argv []) { // parameters tone_type ttype = REAL_COSINE ; double fsr = 3.0 , qnoise = pow ( 10.0 , -60.0 / 20.0 ); int qres = 12 ; double fs = 5000000.0 ; unsigned long long npts = 8192 , num_tones = 1 ; double freq [] = { 50000.0 }, scale [] = { 0.5 }, phase [] = { 0.2 }; // waveforms double * awf ; int32_t * qwf ; // results size_t results_size ; char ** rkeys ; double * rvalues ; // configuration int err_code ; gn_config c = NULL ; err_code = gn_config_gen_tone ( ttype , npts , fs , num_tones , freq , scale , phase , & c ); err_code = gn_config_quantize ( npts , fsr , qres , qnoise , & c ); // generate waveform err_code = gn_gen_real_tone ( & awf , & c ); // quantize waveform err_code = gn_quantize ( & qwf , awf , & c ); // do waveform analysis err_code = gn_get_wfa_results ( & rkeys , & rvalues , & results_size , qwf , & c ); // print results printf ( \"All Waveform Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); // free memory free ( qwf ); free ( awf ); for ( size_t i = 0 ; i < results_size ; i ++ ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , pprint c = genalyzer . config_gen_tone ( 0 , 8192 , 5000000.0 , 1 , [ 50000.0 ], [ 0.5 ], [ 0.2 ]) genalyzer . config_quantize ( 8192 , 3.0 , 12 , pow ( 10.0 , - 60.0 / 20.0 ), c ) awf = genalyzer . gen_real_tone ( c ) qwf = genalyzer . quantize ( awf , c ) wfa_results = genalyzer . get_wfa_results ( qwf , c ) pprint . pprint ( wfa_results ) genalyzer . config_free ( c ) A summary of the results displayed and a brief explanation is as follows: Result Name Description Notes min Min. value max Max. value mid Mid value range Numerical range max-min avg Mean value rms RMS value rmsac RMS (AC) Evaluated as rms 2 -avg 2 min_index Index of min. value max_index Index of max. value Histogram Analysis In the following working example, genalyzer is used to generate a ramp waveform, then the effect of a data-converter on this waveform is simulated and a basic histogram analysis is performed as shown below. C Python #include \"cgenalyzer.h\" #include <stdlib.h> #include <math.h> int main ( int argc , const char * argv []) { // parameters double fsr = 3.0 , qnoise = pow ( 10.0 , -60.0 / 20.0 ); int qres = 12 ; unsigned long long npts = 8192 , ramp_start = 0 , ramp_stop = 2 ; // waveforms double * awf ; int32_t * qwf ; // results uint64_t * hist ; size_t results_size , hist_len ; char ** rkeys ; double * rvalues ; // configuration int err_code ; gn_config c = NULL ; err_code = gn_config_gen_ramp ( npts , ramp_start , ramp_stop , & c ); err_code = gn_config_quantize ( npts , fsr , qres , qnoise , & c ); // generate waveform err_code = gn_gen_ramp ( & awf , & c ); // quantize waveform err_code = gn_quantize ( & qwf , awf , & c ); // compute histogram err_code = gn_histz ( & hist , & hist_len , qwf , & c ); // do waveform analysis err_code = gn_get_ha_results ( & rkeys , & rvalues , & results_size , hist , & c ); // print results printf ( \"All Waveform Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); // free memory free ( qwf ); free ( awf ); for ( size_t i = 0 ; i < results_size ; i ++ ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , pprint c = genalyzer . config_gen_ramp ( 8192 , 0 , 2 ) genalyzer . config_quantize ( 8192 , 3.0 , 12 , pow ( 10.0 , - 60.0 / 20.0 ), c ) awf = genalyzer . gen_ramp ( c ) qwf = genalyzer . quantize ( awf , c ) hist = genalyzer . histz ( qwf , c ) ha_results = genalyzer . get_ha_results ( hist , c ) pprint . pprint ( ha_results ) genalyzer . config_free ( c ) A summary of the results displayed and a brief explanation is as follows: Result Name Description sum Sum of histogram hits first_nz_index First non-zero bin index last_nz_index Last non-zero bin index nz_range Non-zero bin range","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#fourier-analysis","text":"In the following working example, data from an ADALM-PLUTO is used to perform a Fourier analysis as shown below. Note that in the following example, it is assumed that the data is available in the form of a json file. It can be replaced by any other means of loading this data. C Python #include \"cgenalyzer.h\" #include \"../tests/test_genalyzer.h\" #include <stdlib.h> int main ( int argc , const char * argv []) { // read test waveform filename const char * test_filename = \"../tests/test_vectors/test_Pluto_DDS_data_1658159639196.json\" ; int err_code ; int32_t * ref_qwfi , * ref_qwfq ; double * fft_out ; size_t results_size ; char ** rkeys ; double * rvalues , sfdr ; // read parameters tone_type ttype ; int qres ; unsigned long long npts , navg , nfft , tmp_win , num_tones ; double * freq ; GnWindow win ; err_code = read_scalar_from_json_file ( test_filename , \"wf_type\" , ( void * )( & ttype ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"qres\" , ( void * )( & qres ), INT32 ); err_code = read_scalar_from_json_file ( test_filename , \"npts\" , ( void * )( & npts ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"navg\" , ( void * )( & navg ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"nfft\" , ( void * )( & nfft ), UINT64 ); err_code = read_scalar_from_json_file ( test_filename , \"num_tones\" , ( void * )( & num_tones ), UINT64 ); freq = ( double * ) calloc ( num_tones , sizeof ( double )); if ( num_tones > 1 ) err_code = read_array_from_json_file ( test_filename , \"freq\" , freq , DOUBLE , num_tones ); else err_code = read_scalar_from_json_file ( test_filename , \"freq\" , ( void * )( freq ), DOUBLE ); err_code = read_scalar_from_json_file ( test_filename , \"win\" , ( void * )( & tmp_win ), UINT64 ); if ( tmp_win == 1 ) win = GnWindowBlackmanHarris ; else if ( tmp_win == 2 ) win = GnWindowHann ; else if ( tmp_win == 3 ) win = GnWindowNoWindow ; // read reference waveforms ref_qwfi = ( int32_t * ) malloc ( npts * sizeof ( int32_t )); err_code = read_array_from_json_file ( test_filename , \"test_vec_i\" , ref_qwfi , INT32 , npts ); ref_qwfq = ( int32_t * ) malloc ( npts * sizeof ( int32_t )); err_code = read_array_from_json_file ( test_filename , \"test_vec_q\" , ref_qwfq , INT32 , npts ); // configuration gn_config c = NULL ; err_code = gn_config_fftz ( npts , qres , navg , nfft , win , & c ); // FFT of waveform err_code = gn_fftz ( & fft_out , ref_qwfi , ref_qwfq , & c ); // Configure Fourier analysis err_code = gn_config_fa ( freq [ 0 ], & c ); err_code = gn_get_fa_results ( & rkeys , & rvalues , & results_size , fft_out , & c ); printf ( \" \\n All Fourier Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); printf ( \"SFDR - %20.6f \\n \" , sfdr ); // free memory free ( ref_qwfi ); free ( ref_qwfq ); free ( fft_out ); free ( rvalues ); for ( size_t i = 0 ; i < results_size ; ++ i ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , os , json , glob , pprint import matplotlib.pyplot as plt test_dir = os . path . join ( * [ \"..\" , \"..\" , \"..\" , \"tests\" , \"test_vectors\" ]) loc = os . path . dirname ( __file__ ) f = glob . glob ( os . path . join ( loc , test_dir , \"test_Pluto_DDS_data_1658159639196.json\" )) a = open ( f [ 0 ]) data = json . load ( a ) if data [ 'num_tones' ] == 1 : freq_list = [ data [ 'freq' ]] else : freq_list = data [ 'freq' ] qwfi = data [ 'test_vec_i' ] qwfi = [ int ( i ) for i in qwfi ] qwfq = data [ 'test_vec_q' ] qwfq = [ int ( i ) for i in qwfq ] # configure c = genalyzer . config_fftz ( data [ 'npts' ], data [ 'qres' ], data [ 'navg' ], data [ 'nfft' ], data [ 'win' ] - 1 ) genalyzer . config_fa ( freq_list [ 0 ], c ) # compute FFT fft_out_i , fft_out_q = genalyzer . fftz ( qwfi , qwfq , c ) fft_out = [ val for pair in zip ( fft_out_i , fft_out_q ) for val in pair ] # get all Fourier analysis results all_results = genalyzer . get_fa_results ( fft_out , c ) # get a single Fourier analysis result sfdr = genalyzer . get_fa_single_result ( \"sfdr\" , fft_out , c ) # display results pprint . pprint ( all_results ) print ( 'SFDR - ' , sfdr ) # free memory genalyzer . config_free ( c ) A summary of the most important results displayed and a brief explanation is as follows: Result Name Description fsnr Full-scale Signal-to-Noise Ratio snr Signal-to-Noise Ratio sinad Signal-to-Noise and Distortion Ratio sfdr Spurious Free Dynamic Range abn Analysis Band Noise Power nsd Noise Spectral Density carrierindex Index of carrier tone maxspurindex Index of max. spur tone ab_nbins # of bins in analysis band ab_rss Analysis band received signal strength hd_nbins # of bins in used in computing harmonic distortion hd_rss Harmonic distortion band received signal strength imd_nbins # of bins in used in computing inter-modulation distortion imd_rss Inter-modulation distortion band received signal strength thd_nbins # of bins in used in computing total harmonic distortion thd_rss Total harmonic distortion band received signal strength","title":"Fourier Analysis"},{"location":"examples/#waveform-analysis","text":"In the following working example, genalyzer is used to generate a cosine-tone waveform, then the effect of a data-converter on this waveform is simulated and a basic waveform analysis is performed as shown below. C Python #include \"cgenalyzer.h\" #include <stdlib.h> int main ( int argc , const char * argv []) { // parameters tone_type ttype = REAL_COSINE ; double fsr = 3.0 , qnoise = pow ( 10.0 , -60.0 / 20.0 ); int qres = 12 ; double fs = 5000000.0 ; unsigned long long npts = 8192 , num_tones = 1 ; double freq [] = { 50000.0 }, scale [] = { 0.5 }, phase [] = { 0.2 }; // waveforms double * awf ; int32_t * qwf ; // results size_t results_size ; char ** rkeys ; double * rvalues ; // configuration int err_code ; gn_config c = NULL ; err_code = gn_config_gen_tone ( ttype , npts , fs , num_tones , freq , scale , phase , & c ); err_code = gn_config_quantize ( npts , fsr , qres , qnoise , & c ); // generate waveform err_code = gn_gen_real_tone ( & awf , & c ); // quantize waveform err_code = gn_quantize ( & qwf , awf , & c ); // do waveform analysis err_code = gn_get_wfa_results ( & rkeys , & rvalues , & results_size , qwf , & c ); // print results printf ( \"All Waveform Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); // free memory free ( qwf ); free ( awf ); for ( size_t i = 0 ; i < results_size ; i ++ ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , pprint c = genalyzer . config_gen_tone ( 0 , 8192 , 5000000.0 , 1 , [ 50000.0 ], [ 0.5 ], [ 0.2 ]) genalyzer . config_quantize ( 8192 , 3.0 , 12 , pow ( 10.0 , - 60.0 / 20.0 ), c ) awf = genalyzer . gen_real_tone ( c ) qwf = genalyzer . quantize ( awf , c ) wfa_results = genalyzer . get_wfa_results ( qwf , c ) pprint . pprint ( wfa_results ) genalyzer . config_free ( c ) A summary of the results displayed and a brief explanation is as follows: Result Name Description Notes min Min. value max Max. value mid Mid value range Numerical range max-min avg Mean value rms RMS value rmsac RMS (AC) Evaluated as rms 2 -avg 2 min_index Index of min. value max_index Index of max. value","title":"Waveform Analysis"},{"location":"examples/#histogram-analysis","text":"In the following working example, genalyzer is used to generate a ramp waveform, then the effect of a data-converter on this waveform is simulated and a basic histogram analysis is performed as shown below. C Python #include \"cgenalyzer.h\" #include <stdlib.h> #include <math.h> int main ( int argc , const char * argv []) { // parameters double fsr = 3.0 , qnoise = pow ( 10.0 , -60.0 / 20.0 ); int qres = 12 ; unsigned long long npts = 8192 , ramp_start = 0 , ramp_stop = 2 ; // waveforms double * awf ; int32_t * qwf ; // results uint64_t * hist ; size_t results_size , hist_len ; char ** rkeys ; double * rvalues ; // configuration int err_code ; gn_config c = NULL ; err_code = gn_config_gen_ramp ( npts , ramp_start , ramp_stop , & c ); err_code = gn_config_quantize ( npts , fsr , qres , qnoise , & c ); // generate waveform err_code = gn_gen_ramp ( & awf , & c ); // quantize waveform err_code = gn_quantize ( & qwf , awf , & c ); // compute histogram err_code = gn_histz ( & hist , & hist_len , qwf , & c ); // do waveform analysis err_code = gn_get_ha_results ( & rkeys , & rvalues , & results_size , hist , & c ); // print results printf ( \"All Waveform Analysis Results: \\n \" ); for ( size_t i = 0 ; i < results_size ; i ++ ) printf ( \"%4zu%20s%20.6f \\n \" , i , rkeys [ i ], rvalues [ i ]); // free memory free ( qwf ); free ( awf ); for ( size_t i = 0 ; i < results_size ; i ++ ) free ( rkeys [ i ]); free ( rkeys ); gn_config_free ( & c ); return 0 ; } import genalyzer , pprint c = genalyzer . config_gen_ramp ( 8192 , 0 , 2 ) genalyzer . config_quantize ( 8192 , 3.0 , 12 , pow ( 10.0 , - 60.0 / 20.0 ), c ) awf = genalyzer . gen_ramp ( c ) qwf = genalyzer . quantize ( awf , c ) hist = genalyzer . histz ( qwf , c ) ha_results = genalyzer . get_ha_results ( hist , c ) pprint . pprint ( ha_results ) genalyzer . config_free ( c ) A summary of the results displayed and a brief explanation is as follows: Result Name Description sum Sum of histogram hits first_nz_index First non-zero bin index last_nz_index Last non-zero bin index nz_range Non-zero bin range","title":"Histogram Analysis"},{"location":"hw/","text":"","title":"Hardware"},{"location":"setup/","text":"Installation Windows Linux macOS Bindings Python","title":"Set Up"},{"location":"setup/#installation","text":"","title":"Installation"},{"location":"setup/#windows","text":"","title":"Windows"},{"location":"setup/#linux","text":"","title":"Linux"},{"location":"setup/#macos","text":"","title":"macOS"},{"location":"setup/#bindings","text":"","title":"Bindings"},{"location":"setup/#python","text":"","title":"Python"},{"location":"sim/","text":"A number of tests that genalyzer supports assume that the waveform that is analyzed contain one tone or two tones. genalyzer does not support analysis of generic waveforms, which can be decomposed into multiple tone frequencies. In this section, a demonstration of single-tone based measurements supported by genalyzer are described. MATLAB and Python bindings are used to describe the results using the computed FFT and its analysis. First a brief overview of configuring ADALM-PLUTO is shown. For more details, see this page on streaming samples from a supported device using ADI Transceiver Toolbox for MATLAB and this page for the corresponding details when using PyADI-IIO. Configuring ADALM-PLUTO for Tone-Based Measurement in RF Loopback An ADALM-PLUTO is connected in RF loopback and is configured to transmit a 2 MHz complex tone, with the sample rate set to 15.36 MSPS. MATLAB The MATLAB and Python code snippets are shown below. MATLAB Python %% Tx set up tx = adi . Pluto . Tx ; tx . uri = 'ip:pluto' ; tx . DataSource = 'DDS' ; tx . DDSFrequencies = [ 2e6 2e6 ; 0 0 ]; % set DDS complex tone freq to 2 MHz tx . DDSPhases = [ 90e3 0 ; 0 0 ]; % expressed in millidegrees tx . DDSScales = [ 1 1 ; 0 0 ]; tx . CenterFrequency = 2.4e9 ; tx . EnableCustomFilter = true ; tx . CustomFilterFileName = 'LTE10_MHz.ftr' ; % sets PlutoSDR sample - rate to 15.36 MSPS tx . AttenuationChannel0 = - 10 ; tx (); pause ( 1 ); %% Rx set up rx = adi . Pluto . Rx ( 'uri' , 'ip:pluto' ); rx . CenterFrequency = tx . CenterFrequency ; rx . EnableCustomFilter = true ; rx . CustomFilterFileName = 'LTE10_MHz.ftr' ; rx . GainControlModeChannel0 = 'fast_attack' ; y = rx (); y_re = real ( y ); y_im = imag ( y ); tx . release (); rx . release (); # Create radio sdr = adi . Pluto () # Configure properties sdr . rx_lo = 2400000000 sdr . tx_lo = 2400000000 sdr . tx_cyclic_buffer = True sdr . tx_hardwaregain_chan0 = - 10 sdr . gain_control_mode_chan0 = \"fast_attack\" sdr . filter = \"LTE10_MHz.ftr\" fs = int ( sdr . sample_rate ) tone_freq_hz = 2000000 # In Hz tone_scale = 1.0 # Range: 0-1.0 tx_channel = 0 # Starts at 0 sdr . dds_single_tone ( tone_freq_hz , tone_scale , tx_channel ) # Collect data x = sdr . rx () Using genalyzer and ADALM-PLUTO to Compute Tone-Based Measurements for ADALM-PLUTO in RF Loopback In this section, an example on how to use genalyzer for calculating Spurious free dynamic range (SFDR) is provided. Doc in progress. Spurious free dynamic range (SFDR) specifies the capability of the ADC and the system to decipher a carrier signal from other noise or any other spurious frequency. It represents the smallest power signal that can be distinguished from a large interfering signal. Mathematically, it is the ratio between the root mean square (rms) value of the power of a carrier and the rms value of the next most significant spurious signal seen in the frequency domain, such as in a fast Fourier transform (FFT). Hence, by definition, this dynamic range must be free of other spurious frequencies, or spurs. SFDR is quantified as the range, in units of power (dBc), relative from the carrier of interest to the power of the next most significant frequency. However, it also could be referenced to a full-scale signal in units of power (dBFS). This is an important distinction since the carrier of interest may be a relatively lower power signal that is well below the full-scale input to the ADC. When this is the case, the SFDR becomes paramount in distinguishing the signal from other noise and spurious frequencies. A harmonic frequency is an integer multiple of the fundamental frequency. Hence, the SFDR typically will be dominated by the dynamic range between a carrier frequency and the second or third harmonic of the fundamental frequency of interest. In this example, these ideas are demonstrated by using MATLAB's calllib interface to genalyzer. A link to the complete MATLAB script is shown at the bottom of this page. The first step is to create an opaque configuration struct. Using MATLAB and Python bindings, this is done as shown by the code snippet below. MATLAB Python % measurement settings domain = 0 ; % 0 - TIME ; 1 - FREQ type = 2 ; nfft = length ( y ); navg = 1 ; fs = 15.36e6 ; fsr = 0 ; res = 12 ; window = 1 ; % 0 - BlackmanHarris , 1 - Hann , 2 - Rect % setup measurement for time - domain measurement c = libpointer ; % create a null pointer calllib ( 'libgenalyzer' , 'gn_config_tone_meas' , ... c , domain , type , nfft , navg , fs , fsr , res , window , false , false , false ); # setup measurement inputs = dict () inputs [ \"domain_wf\" ] = 0 inputs [ \"type_wf\" ] = 2 inputs [ \"nfft\" ] = len ( x ) inputs [ \"navg\" ] = 1 inputs [ \"fs\" ] = fs inputs [ \"fsr\" ] = 0 inputs [ \"res\" ] = 12 inputs [ \"win\" ] = 1 inputs [ \"freq\" ] = [ 0 ] inputs [ \"phase\" ] = [ 0 ] inputs [ \"scale\" ] = [ 0 ] config_obj = genalyzer . gn_params ( ** inputs ) c = genalyzer . config_tone_meas ( config_obj ) Now, the configuration struct contains the measurement settings in order to calculate the desired metric. SFDR calculation is done as shown in the following code snippets. MATLAB Python % calculating SFDR using the time - domain waveform err_code = libpointer ( 'uint32Ptr' , 0 ); fft_len = libpointer ( 'uint64Ptr' , 0 ); metric = char ( 'SFDR' ); fft_time_re = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); fft_time_im = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); y_interleaved = [ y_re '; y_im' ]; y_interleaved = y_interleaved (:); y_interleavedPtr = libpointer ( 'int32Ptr' , y_interleaved ); sfdr_time = calllib ( 'libgenalyzer' , 'gn_metric' , c , y_interleavedPtr , metric , fft_time_re , fft_time_im , fft_len , err_code ); # compute SFDR result , fft_i , fft_q , err_code = genalyzer . metric_t ( c , x_intrlv , \"SFDR\" ) Note that the FFT calculated for analysis and computing the desired metric is returned by genalyzer. Plotting the FFT computed using genalyzer, we can see that the second harmonic at 4 MHz and its image dominate the remaining spurs. Note that the third harmonic and its image are filtered out by the programmable filter coefficients loaded into ADALM-PLUTO. Since SFDR is by definition, free of spurious frequencies, by examining the above plot, one can estimate SFDR to be around 50 dBc. This values agrees with the SFDR computed by genalyzer. SFDR ( time ) - 49.742253 Note that genalyzer can be configured to compute performance metrics from frequency-domain data as well. In other words, genalyzer can be configured to skip the FFT computation step and only perform analysis of the FFT provided as input. Note that passing a 1 instead of a 0 to the domain argument controls this configuration. This is shown by the MATLAB code snippet below. The same can be accomplished using Python bindings as well. MATLAB Python % setup measurement for freq - domain measurement c = libpointer ; domain = 1 ; % 0 - TIME ; 1 - FREQ calllib ( 'libgenalyzer' , 'gn_config_tone_meas' , ... c , domain , type , nfft , navg , fs , fsr , res , window , false , false , false ); % calculating SFDR using the FFT calculated from time - domain waveform err_code = libpointer ( 'uint32Ptr' , 0 ); fft_len = libpointer ( 'uint64Ptr' , 0 ); fft_y = fft ( hann ( length ( y )) .* y ); ffty_interleaved = [ real ( fft_y ) '; imag(fft_y).' ]; ffty_interleaved = ffty_interleaved (:); ffty_interleavedPtr = libpointer ( 'doublePtr' , ffty_interleaved ); fft_freq_re = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); fft_freq_im = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); sfdr_freq = calllib ( 'libgenalyzer' , 'gn_metric' , c , ffty_interleavedPtr , metric , fft_freq_re , fft_freq_im , fft_len , err_code ); # update domain inputs [ \"domain_wf\" ] = 1 config_obj = genalyzer . gn_params ( ** inputs ) c = genalyzer . config_tone_meas ( config_obj ) # compute SFDR result , fft_i , fft_q , err_code = genalyzer . metric_t ( c , x_intrlv , \"SFDR\" ) The calculated SFDR matches the corresponding result obtained using time-domain waveform closely. SFDR (freq) - 49.742421 Similarly, Signal-to-Noise-and-Distortion (SINAD, or S/(N + D) is the ratio of the rms signal amplitude to the mean value of the root-sum-square (RSS) of all other spectral components, including harmonics, but excluding DC. SINAD is a therefore, an indicator of the overall dynamic performance of an ADC because it includes all components which make up noise and distortion. To compute SINAD, only the","title":"Simulation"},{"location":"theory/","text":"Usage Model Overview Within Genalyzer, bindings to the C++ library are provided to enable users to write C-, Python-, or MATLAB-based scripts to compute the desired performance metrics. In all three cases, the overall structure of a script that links to genalyzer is similar, as shown in more detail in the next subsection. The overall structure in a simulation-only scenario consists of three stages: Configure test Generate waveform Compute metric In the scenario where either the ADC codes or the FFT of the captured ADC codes are available, the structure would be Configure test Load waveform Compute metric In other words, only the second step would change. The overall structure of a C-example that utilizes genalyzer library in the first scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configure test err_code = gn_config_gen_tone (..., & c ); err_code = gn_config_quantize (..., & c ); // generate waveform and quantize err_code = gn_gen_real_tone (..., & c ); err_code = gn_quantize (..., & c ); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , ..., & c ); // free memory gn_config_free ( & c ); return 0 ; } As shown in this (incomplete) illustrative example, a configuration struct is passed to various stages without having to pass the same relevant parameters over and over. The overall structure of a C-example in the second scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configure test err_code = gn_config_fft (..., & c ); // read ADC codes from file err_code = read_array_from_json_file ( filename , \"adc_output_i\" , adc_i , ...); err_code = read_array_from_json_file ( filename , \"adc_output_q\" , adc_q , ...); // compute FFT err_code = gn_fftz ( & fft_out , adc_i , adc_q , & c ); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); // free memory gn_config_free ( & c ); return 0 ; } If on the other hand, the FFT is pre-computed and genalyzer is expected to compute the desired performance metric alone, then only the configuration of FFT related parameters is needed in order for genalyzer to compute the desired performance metric. Note that in the following example, it is assumed that the FFT data is available in the form of a json file. It can be replaced by any other means of loading this data. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configuration err_code = gn_config_fft (..., & c ); // read FFT of ADC codes from file err_code = read_array_from_json_file ( filename , \"fft_test_vec\" , fft_out , ...); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); // free memory gn_config_free ( & c ); return 0 ; } As highlighted by all three illustrative examples above, prior to configuring the test scenario, memory is allocated for the configuration struct by invoking, gn_config_calloc() and to free the allocated memory, gn_config_free() is called. Test Configuration As indicated previously, test configuration is driven through an opaque struct. The public members that are accessible to the user for the purpose of specifying either the waveform or the FFT or the analysis settings are shown in the table below. Catgory Member Name Datatype Description Notes Waveform and FFT settings ttype ENUM Tone type Options: REAL_COSINE REAL_SINE COMPLEX_EXP npts size_t Num. of sample points in the waveform sample_rate double Sample Rate tone_freq double* Tone frequency tone_ampl double* Tone amplitude tone_phase double* Tone phase num_tones size_t Num. of tones fsr double ADC full-scale range qres int Quantization resolution noise_rms double Noise RMS value code_format ENUM Code format of ADC/DAC codes Options: GnCodeFormatOffsetBinary GnCodeFormatTwosComplement nfft size_t FFT order fft_navg size_t Num. of FFT averages data_rate double Data rate shift_freq double Shift frequency win ENUM Window function Options: GnWindowBlackmanHarris GnWindowHann GnWindowNoWindow ramp_start double Start value of ramp ramp_stop double Stop value of ramp Fourier analysis settings obj_key char* Object key comp_key char* Component key ssb_fund int Single side bin - Fundamental ssb_rest int Single side bin - Others max_harm_order int Max. order of harmonic NL analysis settings dnla_signal_type ENUM DNL analysis signal type Options: GnDnlSignalRamp GnDnlSignalTone inla_fit ENUM INL analysis fit Options: GnInlLineFitBestFit GnInlLineFitEndFit GnInlLineFitNoFit As shown by this table, not all parameters are necessary in all use-cases. Consequently, each of the above struct members are accessible through gn_config_set_* functions. For instance, in order to configure sample rate, the function, gn_config_set_sample_rate would be used. Similarly for the other struct members. Additionally, the functions, gn_config_gen_tone , gn_config_gen_ramp , gn_config_quantize , gn_config_fft , and gn_config_fa can be used to configure a set of parameters that are needed in certain specific use-cases. Further details on the function signatures for each of these configuration functions can be found on the API reference page. The following table describes a few use-cases and the relevant members of the configuration struct that need to be set in order to generate a waveform or to perform the desired analysis using genalyzer. Use-case gn_config members to configure Pre-requite function call Function call Generate single-/multi-tone waveform ttype npts sample_rate num_tones tone_freq tone_ampl tone_phase gn_config_gen_tone() gn_gen_tone() Generate ramp waveform npts ramp_start ramp_stop gn_config_gen_ramp() 1 gn_gen_ramp() Quantize waveform npts fsr qres noise_rms gn_config_quantize() 2 gn_quantize() Compute FFT npts qres fft_navg nfft win gn_config_fft() 2 gn_fftz() Compute histogram npts qres gn_config_histz_nla() 2 gn_histz() Compute DNL npts qres gn_config_histz_nla() 2 gn_dnlz() Compute INL npts qres gn_config_histz_nla() 2, 3 gn_inlz() Do Fourier analysis nfft gn_config_fa() 4 gn_get_fa_single_result() or gn_get_fa_results() Do waveform analysis npts gn_config_set_npts() gn_get_wfa_results() Do histogram analysis npts qres gn_config_histz_nla() 2 gn_get_ha_results() Do DNL analysis npts qres gn_config_histz_nla() 2 gn_get_dnla_results() Do INL analysis npts qres gn_config_histz_nla() 2 gn_get_inla_results() 1 noise_rms=0.0 is used. It can be overridden by calling gn_config_set_noise_rms() prior to calling gn_gen_ramp() . 2 code_format=GnCodeFormatTwosComplement is used. It can be overridden by calling gn_config_set_code_format() prior to calling the corresponding pre-requisite function call. 3 inla_fit=GnInlLineFitBestFit is used. It can be overridden by calling gn_config_set_inla_fit() prior to calling gn_config_histz_nla() . 4 The following default settings are used. ssb_fund = 0 ssb_rest = 0 max_harm_order = 3 axis_type=GnFreqAxisTypeDcCenter They can be overridden by calling gn_config_set_ssb_fund() , gn_config_set_ssb_rest() , gn_config_set_max_harm_order() , gn_config_set_axis_type() prior to calling gn_get_fa_results() or gn_get_fa_single_result() . Note that for certain use-cases, the pre-requisite function calls need not be invoked. For instance, given an analog waveform, if the user intends to quantize it and then compute the histogram, calling gn_config_quantize() will set the gn_config struct parameters needed prior to invoking gn_histz() . As indicated in the overall skelton C-script that interfaces with genalyzer, the first stage involves configuring an opaque struct that is provided to the users in order to describe the measurement scenario. Here, users can select between three config_*_meas() function calls in order to select between tone-, ramp- and noise-based performance metric calculations. The opaque struct maintains the state of the test scenario and is passed to the waveform generation and performance metric computation stages subsequently. Tone-based Test Configuration In tone-based test configuration, config_tone_meas() allows users to indicate test settings such as, number of tones, their frequencies, phases, scales, whether real sinusoidal or complex-exponential waveforms are to be generated, the sample-rate, full-scale range of the converter, its resolution etc. Similarly, users can indicate whether the data that will be loaded in the second stage is time-series data or interleaved FFT samples. Moreover, in data-capture scenario i.e., when FFT data is provided to Genalyzer in the second step, the tone frequency, scale and phase information is not required. This test configuration is used for measurements such as SFDR, THD, TIL etc. An example of the config_tone_meas() function call is shown by the following example. // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range 0 , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); Ramp-based Test Configuration In ramp-based test configuration, config_ramp_meas() allows users to indicate test settings such as, the starting and ending values of the ramp waveform in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used in non-linearity based measurements. An example of the config_ramp_meas() function call is shown by the following example. // configuration config_ramp_nl_meas ( & c , npts , // # of data points fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting start , stop , 0.0 ); Noise-based Test Configuration In noise-based test configuration, config_noise_meas() allows users to indicate test settings such as, the noise power level in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used for computing noise spectral density. An example of the config_noise_meas() function call is shown by the following example. // configuration config_noise_meas ( & c , COMPLEX_NOISE , nfft , navg , fs , fsr , res , noise_pwr_lvl , update_fsample , update_fdata , update_fshift ); Waveform Generation The second step, as shown previously, involves either generating the waveform and quantizing it or loading the waveform from a file. The following options are currently supported. cosine/sine and complex exponential waveforms of arbitrary frequency and sample rate ramp waveform Gaussian noise waveform of desired noise power spectral density level In all three cases, the waveform generation functions take two arguments, the opaque configuration struct that has been populated in the first step and a double pointer that will contain the analog waveform generated. The subsequent call to quantize() takes the configuration struct, the analog input waveform and the output quantized waveform obtained from quantizeing the analog waveform based on the resolution contained in the configuration struct. Alternatively, if data is loaded from a file, the configuration struct generated in the first stage will serve as a descriptor of that data. Note that indicating whether time or frequency data is loaded is indicated simply by an argument to the config_tone_meas() call in the first step. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"genalyzer_cwrapper.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(&c, FREQ, ...); // config_tone_meas(&c, TIME,...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; } Performance Metric Computation The final stage involves simply computing the desired performance metric. Metric computation is done by a call to metric() where, the last argument is one of: \"FSNR\" \"NSD\" \"SFDR\" \"SINAD\" \"SNR\" \"TD\" \"THD\" \"TIL Again, the test configuration contained in the opaque struct obtained from the first step is helpful in determinging whether the","title":"Usage Model"},{"location":"theory/#usage-model","text":"","title":"Usage Model"},{"location":"theory/#overview","text":"Within Genalyzer, bindings to the C++ library are provided to enable users to write C-, Python-, or MATLAB-based scripts to compute the desired performance metrics. In all three cases, the overall structure of a script that links to genalyzer is similar, as shown in more detail in the next subsection. The overall structure in a simulation-only scenario consists of three stages: Configure test Generate waveform Compute metric In the scenario where either the ADC codes or the FFT of the captured ADC codes are available, the structure would be Configure test Load waveform Compute metric In other words, only the second step would change. The overall structure of a C-example that utilizes genalyzer library in the first scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configure test err_code = gn_config_gen_tone (..., & c ); err_code = gn_config_quantize (..., & c ); // generate waveform and quantize err_code = gn_gen_real_tone (..., & c ); err_code = gn_quantize (..., & c ); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , ..., & c ); // free memory gn_config_free ( & c ); return 0 ; } As shown in this (incomplete) illustrative example, a configuration struct is passed to various stages without having to pass the same relevant parameters over and over. The overall structure of a C-example in the second scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configure test err_code = gn_config_fft (..., & c ); // read ADC codes from file err_code = read_array_from_json_file ( filename , \"adc_output_i\" , adc_i , ...); err_code = read_array_from_json_file ( filename , \"adc_output_q\" , adc_q , ...); // compute FFT err_code = gn_fftz ( & fft_out , adc_i , adc_q , & c ); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); // free memory gn_config_free ( & c ); return 0 ; } If on the other hand, the FFT is pre-computed and genalyzer is expected to compute the desired performance metric alone, then only the configuration of FFT related parameters is needed in order for genalyzer to compute the desired performance metric. Note that in the following example, it is assumed that the FFT data is available in the form of a json file. It can be replaced by any other means of loading this data. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings gn_config c = NULL ; // configuration err_code = gn_config_fft (..., & c ); // read FFT of ADC codes from file err_code = read_array_from_json_file ( filename , \"fft_test_vec\" , fft_out , ...); // compute metrics err_code = gn_get_fa_single_result ( & sfdr , \"sfdr\" , fft_out , & c ); // free memory gn_config_free ( & c ); return 0 ; } As highlighted by all three illustrative examples above, prior to configuring the test scenario, memory is allocated for the configuration struct by invoking, gn_config_calloc() and to free the allocated memory, gn_config_free() is called.","title":"Overview"},{"location":"theory/#test-configuration","text":"As indicated previously, test configuration is driven through an opaque struct. The public members that are accessible to the user for the purpose of specifying either the waveform or the FFT or the analysis settings are shown in the table below. Catgory Member Name Datatype Description Notes Waveform and FFT settings ttype ENUM Tone type Options: REAL_COSINE REAL_SINE COMPLEX_EXP npts size_t Num. of sample points in the waveform sample_rate double Sample Rate tone_freq double* Tone frequency tone_ampl double* Tone amplitude tone_phase double* Tone phase num_tones size_t Num. of tones fsr double ADC full-scale range qres int Quantization resolution noise_rms double Noise RMS value code_format ENUM Code format of ADC/DAC codes Options: GnCodeFormatOffsetBinary GnCodeFormatTwosComplement nfft size_t FFT order fft_navg size_t Num. of FFT averages data_rate double Data rate shift_freq double Shift frequency win ENUM Window function Options: GnWindowBlackmanHarris GnWindowHann GnWindowNoWindow ramp_start double Start value of ramp ramp_stop double Stop value of ramp Fourier analysis settings obj_key char* Object key comp_key char* Component key ssb_fund int Single side bin - Fundamental ssb_rest int Single side bin - Others max_harm_order int Max. order of harmonic NL analysis settings dnla_signal_type ENUM DNL analysis signal type Options: GnDnlSignalRamp GnDnlSignalTone inla_fit ENUM INL analysis fit Options: GnInlLineFitBestFit GnInlLineFitEndFit GnInlLineFitNoFit As shown by this table, not all parameters are necessary in all use-cases. Consequently, each of the above struct members are accessible through gn_config_set_* functions. For instance, in order to configure sample rate, the function, gn_config_set_sample_rate would be used. Similarly for the other struct members. Additionally, the functions, gn_config_gen_tone , gn_config_gen_ramp , gn_config_quantize , gn_config_fft , and gn_config_fa can be used to configure a set of parameters that are needed in certain specific use-cases. Further details on the function signatures for each of these configuration functions can be found on the API reference page. The following table describes a few use-cases and the relevant members of the configuration struct that need to be set in order to generate a waveform or to perform the desired analysis using genalyzer. Use-case gn_config members to configure Pre-requite function call Function call Generate single-/multi-tone waveform ttype npts sample_rate num_tones tone_freq tone_ampl tone_phase gn_config_gen_tone() gn_gen_tone() Generate ramp waveform npts ramp_start ramp_stop gn_config_gen_ramp() 1 gn_gen_ramp() Quantize waveform npts fsr qres noise_rms gn_config_quantize() 2 gn_quantize() Compute FFT npts qres fft_navg nfft win gn_config_fft() 2 gn_fftz() Compute histogram npts qres gn_config_histz_nla() 2 gn_histz() Compute DNL npts qres gn_config_histz_nla() 2 gn_dnlz() Compute INL npts qres gn_config_histz_nla() 2, 3 gn_inlz() Do Fourier analysis nfft gn_config_fa() 4 gn_get_fa_single_result() or gn_get_fa_results() Do waveform analysis npts gn_config_set_npts() gn_get_wfa_results() Do histogram analysis npts qres gn_config_histz_nla() 2 gn_get_ha_results() Do DNL analysis npts qres gn_config_histz_nla() 2 gn_get_dnla_results() Do INL analysis npts qres gn_config_histz_nla() 2 gn_get_inla_results() 1 noise_rms=0.0 is used. It can be overridden by calling gn_config_set_noise_rms() prior to calling gn_gen_ramp() . 2 code_format=GnCodeFormatTwosComplement is used. It can be overridden by calling gn_config_set_code_format() prior to calling the corresponding pre-requisite function call. 3 inla_fit=GnInlLineFitBestFit is used. It can be overridden by calling gn_config_set_inla_fit() prior to calling gn_config_histz_nla() . 4 The following default settings are used. ssb_fund = 0 ssb_rest = 0 max_harm_order = 3 axis_type=GnFreqAxisTypeDcCenter They can be overridden by calling gn_config_set_ssb_fund() , gn_config_set_ssb_rest() , gn_config_set_max_harm_order() , gn_config_set_axis_type() prior to calling gn_get_fa_results() or gn_get_fa_single_result() . Note that for certain use-cases, the pre-requisite function calls need not be invoked. For instance, given an analog waveform, if the user intends to quantize it and then compute the histogram, calling gn_config_quantize() will set the gn_config struct parameters needed prior to invoking gn_histz() . As indicated in the overall skelton C-script that interfaces with genalyzer, the first stage involves configuring an opaque struct that is provided to the users in order to describe the measurement scenario. Here, users can select between three config_*_meas() function calls in order to select between tone-, ramp- and noise-based performance metric calculations. The opaque struct maintains the state of the test scenario and is passed to the waveform generation and performance metric computation stages subsequently. Tone-based Test Configuration In tone-based test configuration, config_tone_meas() allows users to indicate test settings such as, number of tones, their frequencies, phases, scales, whether real sinusoidal or complex-exponential waveforms are to be generated, the sample-rate, full-scale range of the converter, its resolution etc. Similarly, users can indicate whether the data that will be loaded in the second stage is time-series data or interleaved FFT samples. Moreover, in data-capture scenario i.e., when FFT data is provided to Genalyzer in the second step, the tone frequency, scale and phase information is not required. This test configuration is used for measurements such as SFDR, THD, TIL etc. An example of the config_tone_meas() function call is shown by the following example. // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range 0 , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); Ramp-based Test Configuration In ramp-based test configuration, config_ramp_meas() allows users to indicate test settings such as, the starting and ending values of the ramp waveform in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used in non-linearity based measurements. An example of the config_ramp_meas() function call is shown by the following example. // configuration config_ramp_nl_meas ( & c , npts , // # of data points fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting start , stop , 0.0 ); Noise-based Test Configuration In noise-based test configuration, config_noise_meas() allows users to indicate test settings such as, the noise power level in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used for computing noise spectral density. An example of the config_noise_meas() function call is shown by the following example. // configuration config_noise_meas ( & c , COMPLEX_NOISE , nfft , navg , fs , fsr , res , noise_pwr_lvl , update_fsample , update_fdata , update_fshift );","title":"Test Configuration"},{"location":"theory/#waveform-generation","text":"The second step, as shown previously, involves either generating the waveform and quantizing it or loading the waveform from a file. The following options are currently supported. cosine/sine and complex exponential waveforms of arbitrary frequency and sample rate ramp waveform Gaussian noise waveform of desired noise power spectral density level In all three cases, the waveform generation functions take two arguments, the opaque configuration struct that has been populated in the first step and a double pointer that will contain the analog waveform generated. The subsequent call to quantize() takes the configuration struct, the analog input waveform and the output quantized waveform obtained from quantizeing the analog waveform based on the resolution contained in the configuration struct. Alternatively, if data is loaded from a file, the configuration struct generated in the first stage will serve as a descriptor of that data. Note that indicating whether time or frequency data is loaded is indicated simply by an argument to the config_tone_meas() call in the first step. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"genalyzer_cwrapper.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(&c, FREQ, ...); // config_tone_meas(&c, TIME,...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; }","title":"Waveform Generation"},{"location":"theory/#performance-metric-computation","text":"The final stage involves simply computing the desired performance metric. Metric computation is done by a call to metric() where, the last argument is one of: \"FSNR\" \"NSD\" \"SFDR\" \"SINAD\" \"SNR\" \"TD\" \"THD\" \"TIL Again, the test configuration contained in the opaque struct obtained from the first step is helpful in determinging whether the","title":"Performance Metric Computation"},{"location":"using_genalyzer/","text":"Using Genalyzer As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. ``` c include \"cgenalyzer.h\" int main(int argc, char *argv[]) { // opaque config struct that will contain config settings // config c = NULL; / configuration / // config_tone_meas(...); / waveform generation and quantize / // gen_tone(...); // quantize(...); / compute metrics / // fsnr_val = metric(..., \"FSNR\"); return 0; }``` .. literalinclude:: general_example_skelton1.c :language: C Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. .. literalinclude:: general_example_skelton2.c :language: C .. include:: 02a_test_configuration.rst .. include:: 02b_waveform_generation.rst .. include:: 02c_perf_metric_computation.rst","title":"Using genalyzer"},{"location":"using_genalyzer/#using-genalyzer","text":"As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. ``` c","title":"Using Genalyzer"},{"location":"using_genalyzer/#include-cgenalyzerh","text":"int main(int argc, char *argv[]) { // opaque config struct that will contain config settings // config c = NULL; / configuration / // config_tone_meas(...); / waveform generation and quantize / // gen_tone(...); // quantize(...); / compute metrics / // fsnr_val = metric(..., \"FSNR\"); return 0; }``` .. literalinclude:: general_example_skelton1.c :language: C Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. .. literalinclude:: general_example_skelton2.c :language: C .. include:: 02a_test_configuration.rst .. include:: 02b_waveform_generation.rst .. include:: 02c_perf_metric_computation.rst","title":"include \"cgenalyzer.h\""}]}