{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"genalyzer Library for data converter and general sampled data analysis. Genalyzer is a C++ library that facilitates the computation of commonly used data-converter RF performance metrics in a standards-complaint manner. Genalyzer supports generation of waveforms for characterizing data-converters as well as the computation of performance metrics given the time- or frequency-domain response of data-converters to such waveforms. In other words, users not only have the option of selecting whether or not to opt for waveform generation to characterize data-convereters, but are also able to utilize time-series data or FFT of samples captured from a data-convereter to directly compute the desired performance metrics. Thus, Genalyzer can support a simulation-only scenario or a data-capture scenario. In the first case, the response of a data-converter is simulated given its specifications, in order to compute the expected performance metrics. In the second case, the response of a data-converter is available for Genalyzer to process in the form of a text or binary file. Genalyzer facilitates the computation of common data converter performance metrics in a standards-complaint manner. The terminology and definitions for various common performance metrics are adopted from the IEEE Standard for Terminology and Test Methods for Analog-to-Digital Converters (IEEE 1241-2010) and the IEEE Standard for Terminology and Test Methods of Digital-to-Analog Converter Devices (IEEE 1658-2011) both published by Instrumentation and Measurement/Waveform Generation, Measurement, and Analysis - Technical Committee 10 (IM/WM&A - TC10). Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#genalyzer","text":"Library for data converter and general sampled data analysis. Genalyzer is a C++ library that facilitates the computation of commonly used data-converter RF performance metrics in a standards-complaint manner. Genalyzer supports generation of waveforms for characterizing data-converters as well as the computation of performance metrics given the time- or frequency-domain response of data-converters to such waveforms. In other words, users not only have the option of selecting whether or not to opt for waveform generation to characterize data-convereters, but are also able to utilize time-series data or FFT of samples captured from a data-convereter to directly compute the desired performance metrics. Thus, Genalyzer can support a simulation-only scenario or a data-capture scenario. In the first case, the response of a data-converter is simulated given its specifications, in order to compute the expected performance metrics. In the second case, the response of a data-converter is available for Genalyzer to process in the form of a text or binary file. Genalyzer facilitates the computation of common data converter performance metrics in a standards-complaint manner. The terminology and definitions for various common performance metrics are adopted from the IEEE Standard for Terminology and Test Methods for Analog-to-Digital Converters (IEEE 1241-2010) and the IEEE Standard for Terminology and Test Methods of Digital-to-Analog Converter Devices (IEEE 1658-2011) both published by Instrumentation and Measurement/Waveform Generation, Measurement, and Analysis - Technical Committee 10 (IM/WM&A - TC10).","title":"genalyzer"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"cgenalyzer_8h/","text":"Functions Name Description gn_config_tone_gen Configure test based on real sinusoidal or complex exponential tones. gn_config_tone_meas Configure test based on real sinusoidal or complex exponential tones. gn_config_noise_meas Configure test based on noise waveform. gn_config_tone_nl_meas Configure non-linearity test based on real sinusoidal tone. gn_config_ramp_nl_meas Configure non-linearity test based on ramp waveform. gn_gen_tone Generate sinusoidal tone based on supplied configuration. gn_gen_noise Generate noise based on supplied configuration. gn_gen_ramp Generate ramp based on supplied configuration. gn_quantize Quantize waveform based on supplied configuration. gn_rfft Compute complex FFT of real waveform based on supplied configuration. gn_fft Compute complex FFT of real waveform based on supplied configuration. gn_metric Compute desired data-converter performance metric. gn_compute_dnl Compute DNL of the data-converter. gn_compute_inl Compute INL of the data-converter. Types Name enum waveform_type enum meas_domain enum int_repr enum win_func typedef enum waveform_type waveform_type typedef enum meas_domain meas_domain typedef enum int_repr int_repr typedef enum win_func win_func typedef struct gn_config_s * gn_config typedef gn_config gn_config_tone Library Functions function gn_config_tone_gen void gn_config_tone_gen ( gn_config_tone * c , meas_domain m_domain , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , double * tone_freq , double * tone_ampl , double * tone_phase , size_t num_tones , win_func window , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on real sinusoidal or complex exponential tones. Parameter Description c Configuration structure of test and waveform to generate m_domain Input ENUM value to indicate time/frequency domain of input waveform wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate num_tones Input number of tones to generate window Window function to apply for computing FFT fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift function gn_config_tone_meas void gn_config_tone_meas ( gn_config_tone * c , meas_domain m_domain , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , win_func window , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on real sinusoidal or complex exponential tones. Parameter Description c Configuration structure of test and waveform to generate m_domain Input ENUM value to indicate time/frequency domain of input waveform wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter window Window function to apply for computing FFT fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift function gn_config_noise_meas void gn_config_noise_meas ( gn_config * c , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , double noise_pwr_lvl , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on noise waveform. Parameter Description c Configuration structure of test and waveform to generate wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter noise_pwr_lvl Input noise power of the data converter fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift function gn_config_tone_nl_meas void gn_config_tone_nl_meas ( gn_config * c , waveform_type wf_type , size_t npts , double sample_rate , double full_scale_range , int resolution , double * tone_freq , double * tone_ampl , double * tone_phase , size_t num_tones ) Configure non-linearity test based on real sinusoidal tone. Parameter Description c Configuration structure of test and waveform to generate wf_type Input ENUM value to indicate input waveform type as cosine real or sine real npts Input number desired for the waveform generated or contained in the provided data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate num_tones Input number of tones to generate function gn_config_ramp_nl_meas void gn_config_ramp_nl_meas ( gn_config * c , size_t npts , double sample_rate , double full_scale_range , int resolution , double start , double stop , double irnoise ) Configure non-linearity test based on ramp waveform. Parameter Description c Configuration structure of test and waveform to generate npts Input number desired for the waveform generated or contained in the provided data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter start Input start of the ramp waveform stop Input stop of the ramp waveform irnoise Input IR noise function gn_gen_tone void gn_gen_tone ( gn_config c , double ** result , size_t * len ) Generate sinusoidal tone based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of tone generated len Output length of the generated tone in samples function gn_gen_noise void gn_gen_noise ( gn_config c , double ** result ) Generate noise based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of noise generated function gn_gen_ramp void gn_gen_ramp ( gn_config c , double ** result , size_t * len ) Generate ramp based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of ramp generated len Output length of the generated tone in samples function gn_quantize void gn_quantize ( gn_config c , const double * awf , int32_t ** result ) Quantize waveform based on supplied configuration. Parameter Description c Configuration structure of test awf Input waveform to quantize result Output array of waveform quantized function gn_rfft void gn_rfft ( gn_config c , int32_t * qwf , double ** fft_cplx_re , double ** fft_cplx_im , size_t * len ) Compute complex FFT of real waveform based on supplied configuration. Parameter Description c Configuration structure of test qwf Input real quantized waveform fft_cplx_re Output In-phase array of FFT of Input quantized real waveform fft_cplx_im Output Quadrature-phase array of FFT of Input quantized real waveform len Output length of the generated tone in samples function gn_fft void gn_fft ( gn_config c , int32_t * qwf_i , int32_t * qwf_q , double ** fft_cplx_re , double ** fft_cplx_im , size_t * len ) Compute complex FFT of real waveform based on supplied configuration. Parameter Description c Configuration structure of test qwf_i Input real part of quantized waveform qwf_q Input imaginary part of quantized waveform fft_cplx_re Output In-phase array of FFT of quantized real waveform fft_cplx_im Output Quadrature-phase array of FFT of quantized real waveform len Output length of the generated tone in samples function gn_metric double gn_metric ( gn_config c , const void * input , const char * m_name , double ** fft_re , double ** fft_im , size_t * len , unsigned int * error_code ) Compute desired data-converter performance metric. Parameter Description c Configuration structure of test input Input quantized real waveform m_name Input name of the performance metric fft_re Output real part of FFT computed. fft_im Output imaginary part of FFT computed. len Length of the FFT generated error_code Output error code. If 0, no error occurred. function gn_compute_dnl void gn_compute_dnl ( gn_config c , int * qwf , int32_t ** bins , int64_t ** hits , double ** dnl_data ) Compute DNL of the data-converter. Parameter Description c Configuration structure of test qwf Input quantized real waveform bins Output bins of histogram of codes hits Output frequency of bins dnl_data Output DNL computed function gn_compute_inl void gn_compute_inl ( gn_config c , int * qwf , int32_t ** bins , int64_t ** hits , double ** dnl_data , double ** inl_data ) Compute INL of the data-converter. Parameter Description c Configuration structure of test qwf Input quantized real waveform bins Output bins of histogram of codes hits Output frequency of bins dnl_data Output DNL computed inl_data Output INL computed Library Types enum waveform_type Enumerator Value Description REAL_COSINE REAL_SINE COMPLEX_EXP REAL_NOISE COMPLEX_NOISE RAMP enum meas_domain Enumerator Value Description TIME FREQ enum int_repr Enumerator Value Description I32 I64 enum win_func Enumerator Value Description BlackmanHarris Hann Rect typedef waveform_type typedef enum waveform_type waveform_type ; typedef meas_domain typedef enum meas_domain meas_domain ; typedef int_repr typedef enum int_repr int_repr ; typedef win_func typedef enum win_func win_func ; typedef gn_config typedef struct gn_config_s * gn_config ; typedef gn_config_tone typedef gn_config gn_config_tone ; Updated on 2022-02-07 at 23:20:29 +0000","title":"API Reference"},{"location":"cgenalyzer_8h/#functions","text":"Name Description gn_config_tone_gen Configure test based on real sinusoidal or complex exponential tones. gn_config_tone_meas Configure test based on real sinusoidal or complex exponential tones. gn_config_noise_meas Configure test based on noise waveform. gn_config_tone_nl_meas Configure non-linearity test based on real sinusoidal tone. gn_config_ramp_nl_meas Configure non-linearity test based on ramp waveform. gn_gen_tone Generate sinusoidal tone based on supplied configuration. gn_gen_noise Generate noise based on supplied configuration. gn_gen_ramp Generate ramp based on supplied configuration. gn_quantize Quantize waveform based on supplied configuration. gn_rfft Compute complex FFT of real waveform based on supplied configuration. gn_fft Compute complex FFT of real waveform based on supplied configuration. gn_metric Compute desired data-converter performance metric. gn_compute_dnl Compute DNL of the data-converter. gn_compute_inl Compute INL of the data-converter.","title":"Functions"},{"location":"cgenalyzer_8h/#types","text":"Name enum waveform_type enum meas_domain enum int_repr enum win_func typedef enum waveform_type waveform_type typedef enum meas_domain meas_domain typedef enum int_repr int_repr typedef enum win_func win_func typedef struct gn_config_s * gn_config typedef gn_config gn_config_tone","title":"Types"},{"location":"cgenalyzer_8h/#library-functions","text":"","title":"Library Functions"},{"location":"cgenalyzer_8h/#function-gn_config_tone_gen","text":"void gn_config_tone_gen ( gn_config_tone * c , meas_domain m_domain , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , double * tone_freq , double * tone_ampl , double * tone_phase , size_t num_tones , win_func window , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on real sinusoidal or complex exponential tones. Parameter Description c Configuration structure of test and waveform to generate m_domain Input ENUM value to indicate time/frequency domain of input waveform wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate num_tones Input number of tones to generate window Window function to apply for computing FFT fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift","title":"function gn_config_tone_gen"},{"location":"cgenalyzer_8h/#function-gn_config_tone_meas","text":"void gn_config_tone_meas ( gn_config_tone * c , meas_domain m_domain , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , win_func window , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on real sinusoidal or complex exponential tones. Parameter Description c Configuration structure of test and waveform to generate m_domain Input ENUM value to indicate time/frequency domain of input waveform wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter window Window function to apply for computing FFT fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift","title":"function gn_config_tone_meas"},{"location":"cgenalyzer_8h/#function-gn_config_noise_meas","text":"void gn_config_noise_meas ( gn_config * c , waveform_type wf_type , size_t fft_order , int num_avgs , double sample_rate , double full_scale_range , int resolution , double noise_pwr_lvl , bool fsample_update , bool fdata_update , bool fshift_update ) Configure test based on noise waveform. Parameter Description c Configuration structure of test and waveform to generate wf_type Input ENUM value to indicate input waveform type as real or complex fft_order Input FFT order desired for the waveform generated or contained in the provided FFT data num_avgs Input number of FFT averages desired for the waveform generated or contained in the provided FFT data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter noise_pwr_lvl Input noise power of the data converter fsample_update Input Boolean value to update fsample fdata_update Input Boolean value to update fdata fshift_update Input Boolean value to update fshift","title":"function gn_config_noise_meas"},{"location":"cgenalyzer_8h/#function-gn_config_tone_nl_meas","text":"void gn_config_tone_nl_meas ( gn_config * c , waveform_type wf_type , size_t npts , double sample_rate , double full_scale_range , int resolution , double * tone_freq , double * tone_ampl , double * tone_phase , size_t num_tones ) Configure non-linearity test based on real sinusoidal tone. Parameter Description c Configuration structure of test and waveform to generate wf_type Input ENUM value to indicate input waveform type as cosine real or sine real npts Input number desired for the waveform generated or contained in the provided data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter tone_freq Input array of tone frequencies to generate tone_ampl Input array of tone scales to generate tone_phase Input array of tone phases to generate num_tones Input number of tones to generate","title":"function gn_config_tone_nl_meas"},{"location":"cgenalyzer_8h/#function-gn_config_ramp_nl_meas","text":"void gn_config_ramp_nl_meas ( gn_config * c , size_t npts , double sample_rate , double full_scale_range , int resolution , double start , double stop , double irnoise ) Configure non-linearity test based on ramp waveform. Parameter Description c Configuration structure of test and waveform to generate npts Input number desired for the waveform generated or contained in the provided data sample_rate Input Sample rate of the data converter full_scale_range Input full-scale-range of the data converter resolution Input resolution of the data converter start Input start of the ramp waveform stop Input stop of the ramp waveform irnoise Input IR noise","title":"function gn_config_ramp_nl_meas"},{"location":"cgenalyzer_8h/#function-gn_gen_tone","text":"void gn_gen_tone ( gn_config c , double ** result , size_t * len ) Generate sinusoidal tone based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of tone generated len Output length of the generated tone in samples","title":"function gn_gen_tone"},{"location":"cgenalyzer_8h/#function-gn_gen_noise","text":"void gn_gen_noise ( gn_config c , double ** result ) Generate noise based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of noise generated","title":"function gn_gen_noise"},{"location":"cgenalyzer_8h/#function-gn_gen_ramp","text":"void gn_gen_ramp ( gn_config c , double ** result , size_t * len ) Generate ramp based on supplied configuration. Parameter Description c Configuration structure of test and waveform to generate result Output array of ramp generated len Output length of the generated tone in samples","title":"function gn_gen_ramp"},{"location":"cgenalyzer_8h/#function-gn_quantize","text":"void gn_quantize ( gn_config c , const double * awf , int32_t ** result ) Quantize waveform based on supplied configuration. Parameter Description c Configuration structure of test awf Input waveform to quantize result Output array of waveform quantized","title":"function gn_quantize"},{"location":"cgenalyzer_8h/#function-gn_rfft","text":"void gn_rfft ( gn_config c , int32_t * qwf , double ** fft_cplx_re , double ** fft_cplx_im , size_t * len ) Compute complex FFT of real waveform based on supplied configuration. Parameter Description c Configuration structure of test qwf Input real quantized waveform fft_cplx_re Output In-phase array of FFT of Input quantized real waveform fft_cplx_im Output Quadrature-phase array of FFT of Input quantized real waveform len Output length of the generated tone in samples","title":"function gn_rfft"},{"location":"cgenalyzer_8h/#function-gn_fft","text":"void gn_fft ( gn_config c , int32_t * qwf_i , int32_t * qwf_q , double ** fft_cplx_re , double ** fft_cplx_im , size_t * len ) Compute complex FFT of real waveform based on supplied configuration. Parameter Description c Configuration structure of test qwf_i Input real part of quantized waveform qwf_q Input imaginary part of quantized waveform fft_cplx_re Output In-phase array of FFT of quantized real waveform fft_cplx_im Output Quadrature-phase array of FFT of quantized real waveform len Output length of the generated tone in samples","title":"function gn_fft"},{"location":"cgenalyzer_8h/#function-gn_metric","text":"double gn_metric ( gn_config c , const void * input , const char * m_name , double ** fft_re , double ** fft_im , size_t * len , unsigned int * error_code ) Compute desired data-converter performance metric. Parameter Description c Configuration structure of test input Input quantized real waveform m_name Input name of the performance metric fft_re Output real part of FFT computed. fft_im Output imaginary part of FFT computed. len Length of the FFT generated error_code Output error code. If 0, no error occurred.","title":"function gn_metric"},{"location":"cgenalyzer_8h/#function-gn_compute_dnl","text":"void gn_compute_dnl ( gn_config c , int * qwf , int32_t ** bins , int64_t ** hits , double ** dnl_data ) Compute DNL of the data-converter. Parameter Description c Configuration structure of test qwf Input quantized real waveform bins Output bins of histogram of codes hits Output frequency of bins dnl_data Output DNL computed","title":"function gn_compute_dnl"},{"location":"cgenalyzer_8h/#function-gn_compute_inl","text":"void gn_compute_inl ( gn_config c , int * qwf , int32_t ** bins , int64_t ** hits , double ** dnl_data , double ** inl_data ) Compute INL of the data-converter. Parameter Description c Configuration structure of test qwf Input quantized real waveform bins Output bins of histogram of codes hits Output frequency of bins dnl_data Output DNL computed inl_data Output INL computed","title":"function gn_compute_inl"},{"location":"cgenalyzer_8h/#library-types","text":"","title":"Library Types"},{"location":"cgenalyzer_8h/#enum-waveform_type","text":"Enumerator Value Description REAL_COSINE REAL_SINE COMPLEX_EXP REAL_NOISE COMPLEX_NOISE RAMP","title":"enum waveform_type"},{"location":"cgenalyzer_8h/#enum-meas_domain","text":"Enumerator Value Description TIME FREQ","title":"enum meas_domain"},{"location":"cgenalyzer_8h/#enum-int_repr","text":"Enumerator Value Description I32 I64","title":"enum int_repr"},{"location":"cgenalyzer_8h/#enum-win_func","text":"Enumerator Value Description BlackmanHarris Hann Rect","title":"enum win_func"},{"location":"cgenalyzer_8h/#typedef-waveform_type","text":"typedef enum waveform_type waveform_type ;","title":"typedef waveform_type"},{"location":"cgenalyzer_8h/#typedef-meas_domain","text":"typedef enum meas_domain meas_domain ;","title":"typedef meas_domain"},{"location":"cgenalyzer_8h/#typedef-int_repr","text":"typedef enum int_repr int_repr ;","title":"typedef int_repr"},{"location":"cgenalyzer_8h/#typedef-win_func","text":"typedef enum win_func win_func ;","title":"typedef win_func"},{"location":"cgenalyzer_8h/#typedef-gn_config","text":"typedef struct gn_config_s * gn_config ;","title":"typedef gn_config"},{"location":"cgenalyzer_8h/#typedef-gn_config_tone","text":"typedef gn_config gn_config_tone ; Updated on 2022-02-07 at 23:20:29 +0000","title":"typedef gn_config_tone"},{"location":"examples/","text":"Examples A complete working example to generate and compute a tone-based data-converter performance metric is shown below. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // read configuration settings from a file const char * test_filename = argv [ 1 ]; printf ( \"%s \\n \" , test_filename ); // variables to hold configuration settings double * awf ; int * qwf ; size_t nfft = atoll ( extract_token ( test_filename , \"nfft\" )); size_t num_tones = atoll ( extract_token ( test_filename , \"num_tones\" )); int navg = atoi ( extract_token ( test_filename , \"navg\" )); double fs = atof ( extract_token ( test_filename , \"fs\" )); double fdata = fs , fshift = fs ; double fsr = atof ( extract_token ( test_filename , \"fsr\" )); double * freq = ( double * ) calloc ( num_tones , sizeof ( double )); double * scale = ( double * ) calloc ( num_tones , sizeof ( double )); double * phase = ( double * ) calloc ( num_tones , sizeof ( double )); char tmp_token [ 10 ]; for ( int n = 0 ; n < num_tones ; n ++ ) { sprintf ( tmp_token , \"freq%d\" , n ); freq [ n ] = atof ( extract_token ( test_filename , tmp_token )); sprintf ( tmp_token , \"scale%d\" , n ); scale [ n ] = atof ( extract_token ( test_filename , tmp_token )); sprintf ( tmp_token , \"phase%d\" , n ); phase [ n ] = atof ( extract_token ( test_filename , tmp_token )); } // opaque config struct that will contain config settings config c = NULL ; // configuration config_tone_meas ( & c , FREQ , COMPLEX_EXP , nfft , navg , fs , fsr , res , & freq , & scale , & phase , 1 , update_fsample , update_fdata , update_fshift ); // waveform generation gen_tone ( c , & awf ); quantize ( c , awf , & qwf ); // compute metrics fsnr_val = metric ( c , qwf , \"FSNR\" ); sfdr_val = metric ( c , qwf , \"SFDR\" ); sinad_val = metric ( c , qwf , \"SINAD\" ); free ( awf ); free ( qwf ); return 0 ; } Similarly, a complete working example that utilizes recorded waveforms from a data-converter to characterize its performance is shown by the following example. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"test_genalyzer.h\" #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // read test waveform const char * test_filename_ip = argv [ 1 ]; printf ( \"%s \\n \" , test_filename_ip ); meas_domain domain_wf = atoll ( extract_token ( test_filename_ip , \"domain_wf\" )); waveform_type type_wf = atoll ( extract_token ( test_filename_ip , \"type_wf\" )); size_t nfft = atoll ( extract_token ( test_filename_ip , \"nfft\" )); size_t num_tones = atoll ( extract_token ( test_filename_ip , \"num_tones\" )); int res = atoi ( extract_token ( test_filename_ip , \"res\" )); int navg = atoi ( extract_token ( test_filename_ip , \"navg\" )); double fs = atof ( extract_token ( test_filename_ip , \"fs\" )); double fdata = fs , fshift = fs ; double fsr = atof ( extract_token ( test_filename_ip , \"fsr\" )); double * freq = ( double * ) calloc ( num_tones , sizeof ( double )); double * scale = ( double * ) calloc ( num_tones , sizeof ( double )); double * phase = ( double * ) calloc ( num_tones , sizeof ( double )); char tmp_token [ 10 ]; for ( int n = 0 ; n < num_tones ; n ++ ) { sprintf ( tmp_token , \"freq%d\" , n ); freq [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); sprintf ( tmp_token , \"scale%d\" , n ); scale [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); sprintf ( tmp_token , \"phase%d\" , n ); phase [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); } size_t npts = 2 * nfft * navg ; int qwf [ npts ]; config c = NULL ; // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); // read quantized input waveform read_file_to_array ( test_filename_ip , ( void * ) qwf , INT32 ); // compute metrics fsnr_val = metric ( c , qwf , \"FSNR\" ); sfdr_val = metric ( c , qwf , \"SFDR\" ); sinad_val = metric ( c , qwf , \"SINAD\" ); free ( awf ); free ( qwf ); return 0 ; }","title":"Examples"},{"location":"examples/#examples","text":"A complete working example to generate and compute a tone-based data-converter performance metric is shown below. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // read configuration settings from a file const char * test_filename = argv [ 1 ]; printf ( \"%s \\n \" , test_filename ); // variables to hold configuration settings double * awf ; int * qwf ; size_t nfft = atoll ( extract_token ( test_filename , \"nfft\" )); size_t num_tones = atoll ( extract_token ( test_filename , \"num_tones\" )); int navg = atoi ( extract_token ( test_filename , \"navg\" )); double fs = atof ( extract_token ( test_filename , \"fs\" )); double fdata = fs , fshift = fs ; double fsr = atof ( extract_token ( test_filename , \"fsr\" )); double * freq = ( double * ) calloc ( num_tones , sizeof ( double )); double * scale = ( double * ) calloc ( num_tones , sizeof ( double )); double * phase = ( double * ) calloc ( num_tones , sizeof ( double )); char tmp_token [ 10 ]; for ( int n = 0 ; n < num_tones ; n ++ ) { sprintf ( tmp_token , \"freq%d\" , n ); freq [ n ] = atof ( extract_token ( test_filename , tmp_token )); sprintf ( tmp_token , \"scale%d\" , n ); scale [ n ] = atof ( extract_token ( test_filename , tmp_token )); sprintf ( tmp_token , \"phase%d\" , n ); phase [ n ] = atof ( extract_token ( test_filename , tmp_token )); } // opaque config struct that will contain config settings config c = NULL ; // configuration config_tone_meas ( & c , FREQ , COMPLEX_EXP , nfft , navg , fs , fsr , res , & freq , & scale , & phase , 1 , update_fsample , update_fdata , update_fshift ); // waveform generation gen_tone ( c , & awf ); quantize ( c , awf , & qwf ); // compute metrics fsnr_val = metric ( c , qwf , \"FSNR\" ); sfdr_val = metric ( c , qwf , \"SFDR\" ); sinad_val = metric ( c , qwf , \"SINAD\" ); free ( awf ); free ( qwf ); return 0 ; } Similarly, a complete working example that utilizes recorded waveforms from a data-converter to characterize its performance is shown by the following example. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"test_genalyzer.h\" #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // read test waveform const char * test_filename_ip = argv [ 1 ]; printf ( \"%s \\n \" , test_filename_ip ); meas_domain domain_wf = atoll ( extract_token ( test_filename_ip , \"domain_wf\" )); waveform_type type_wf = atoll ( extract_token ( test_filename_ip , \"type_wf\" )); size_t nfft = atoll ( extract_token ( test_filename_ip , \"nfft\" )); size_t num_tones = atoll ( extract_token ( test_filename_ip , \"num_tones\" )); int res = atoi ( extract_token ( test_filename_ip , \"res\" )); int navg = atoi ( extract_token ( test_filename_ip , \"navg\" )); double fs = atof ( extract_token ( test_filename_ip , \"fs\" )); double fdata = fs , fshift = fs ; double fsr = atof ( extract_token ( test_filename_ip , \"fsr\" )); double * freq = ( double * ) calloc ( num_tones , sizeof ( double )); double * scale = ( double * ) calloc ( num_tones , sizeof ( double )); double * phase = ( double * ) calloc ( num_tones , sizeof ( double )); char tmp_token [ 10 ]; for ( int n = 0 ; n < num_tones ; n ++ ) { sprintf ( tmp_token , \"freq%d\" , n ); freq [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); sprintf ( tmp_token , \"scale%d\" , n ); scale [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); sprintf ( tmp_token , \"phase%d\" , n ); phase [ n ] = atof ( extract_token ( test_filename_ip , tmp_token )); } size_t npts = 2 * nfft * navg ; int qwf [ npts ]; config c = NULL ; // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); // read quantized input waveform read_file_to_array ( test_filename_ip , ( void * ) qwf , INT32 ); // compute metrics fsnr_val = metric ( c , qwf , \"FSNR\" ); sfdr_val = metric ( c , qwf , \"SFDR\" ); sinad_val = metric ( c , qwf , \"SINAD\" ); free ( awf ); free ( qwf ); return 0 ; }","title":"Examples"},{"location":"hw/","text":"","title":"Hardware"},{"location":"setup/","text":"Installation Windows Linux macOS Bindings Python","title":"Set Up"},{"location":"setup/#installation","text":"","title":"Installation"},{"location":"setup/#windows","text":"","title":"Windows"},{"location":"setup/#linux","text":"","title":"Linux"},{"location":"setup/#macos","text":"","title":"macOS"},{"location":"setup/#bindings","text":"","title":"Bindings"},{"location":"setup/#python","text":"","title":"Python"},{"location":"sim/","text":"A number of tests that genalyzer supports assume that the waveform that is analyzed contain one tone or two tones. genalyzer does not support analysis of generic waveforms, which can be decomposed into multiple tone frequencies. In this section, a demonstration of single-tone based measurements supported by genalyzer are described. MATLAB and Python bindings are used to describe the results using the computed FFT and its analysis. First a brief overview of configuring ADALM-PLUTO is shown. For more details, see this page on streaming samples from a supported device using ADI Transceiver Toolbox for MATLAB and this page for the corresponding details when using PyADI-IIO. Configuring ADALM-PLUTO for Tone-Based Measurement in RF Loopback An ADALM-PLUTO is connected in RF loopback and is configured to transmit a 2 MHz complex tone, with the sample rate set to 15.36 MSPS. MATLAB The MATLAB and Python code snippets are shown below. MATLAB Python %% Tx set up tx = adi . Pluto . Tx ; tx . uri = 'ip:pluto' ; tx . DataSource = 'DDS' ; tx . DDSFrequencies = [ 2e6 2e6 ; 0 0 ]; % set DDS complex tone freq to 2 MHz tx . DDSPhases = [ 90e3 0 ; 0 0 ]; % expressed in millidegrees tx . DDSScales = [ 1 1 ; 0 0 ]; tx . CenterFrequency = 2.4e9 ; tx . EnableCustomFilter = true ; tx . CustomFilterFileName = 'LTE10_MHz.ftr' ; % sets PlutoSDR sample - rate to 15.36 MSPS tx . AttenuationChannel0 = - 10 ; tx (); pause ( 1 ); %% Rx set up rx = adi . Pluto . Rx ( 'uri' , 'ip:pluto' ); rx . CenterFrequency = tx . CenterFrequency ; rx . EnableCustomFilter = true ; rx . CustomFilterFileName = 'LTE10_MHz.ftr' ; rx . GainControlModeChannel0 = 'fast_attack' ; y = rx (); y_re = real ( y ); y_im = imag ( y ); tx . release (); rx . release (); # Create radio sdr = adi . Pluto () # Configure properties sdr . rx_lo = 2400000000 sdr . tx_lo = 2400000000 sdr . tx_cyclic_buffer = True sdr . tx_hardwaregain_chan0 = - 10 sdr . gain_control_mode_chan0 = \"fast_attack\" sdr . filter = \"LTE10_MHz.ftr\" fs = int ( sdr . sample_rate ) tone_freq_hz = 2000000 # In Hz tone_scale = 1.0 # Range: 0-1.0 tx_channel = 0 # Starts at 0 sdr . dds_single_tone ( tone_freq_hz , tone_scale , tx_channel ) # Collect data x = sdr . rx () Using genalyzer and ADALM-PLUTO to Compute Tone-Based Measurements for ADALM-PLUTO in RF Loopback In this section, an example on how to use genalyzer for calculating Spurious free dynamic range (SFDR) is provided. Doc in progress. Spurious free dynamic range (SFDR) specifies the capability of the ADC and the system to decipher a carrier signal from other noise or any other spurious frequency. It represents the smallest power signal that can be distinguished from a large interfering signal. Mathematically, it is the ratio between the root mean square (rms) value of the power of a carrier and the rms value of the next most significant spurious signal seen in the frequency domain, such as in a fast Fourier transform (FFT). Hence, by definition, this dynamic range must be free of other spurious frequencies, or spurs. SFDR is quantified as the range, in units of power (dBc), relative from the carrier of interest to the power of the next most significant frequency. However, it also could be referenced to a full-scale signal in units of power (dBFS). This is an important distinction since the carrier of interest may be a relatively lower power signal that is well below the full-scale input to the ADC. When this is the case, the SFDR becomes paramount in distinguishing the signal from other noise and spurious frequencies. A harmonic frequency is an integer multiple of the fundamental frequency. Hence, the SFDR typically will be dominated by the dynamic range between a carrier frequency and the second or third harmonic of the fundamental frequency of interest. In this example, these ideas are demonstrated by using MATLAB's calllib interface to genalyzer. A link to the complete MATLAB script is shown at the bottom of this page. The first step is to create an opaque configuration struct. Using MATLAB and Python bindings, this is done as shown by the code snippet below. MATLAB Python % measurement settings domain = 0 ; % 0 - TIME ; 1 - FREQ type = 2 ; nfft = length ( y ); navg = 1 ; fs = 15.36e6 ; fsr = 0 ; res = 12 ; window = 1 ; % 0 - BlackmanHarris , 1 - Hann , 2 - Rect % setup measurement for time - domain measurement c = libpointer ; % create a null pointer calllib ( 'libgenalyzer' , 'gn_config_tone_meas' , ... c , domain , type , nfft , navg , fs , fsr , res , window , false , false , false ); # setup measurement inputs = dict () inputs [ \"domain_wf\" ] = 0 inputs [ \"type_wf\" ] = 2 inputs [ \"nfft\" ] = len ( x ) inputs [ \"navg\" ] = 1 inputs [ \"fs\" ] = fs inputs [ \"fsr\" ] = 0 inputs [ \"res\" ] = 12 inputs [ \"win\" ] = 1 inputs [ \"freq\" ] = [ 0 ] inputs [ \"phase\" ] = [ 0 ] inputs [ \"scale\" ] = [ 0 ] config_obj = genalyzer . gn_params ( ** inputs ) c = genalyzer . config_tone_meas ( config_obj ) Now, the configuration struct contains the measurement settings in order to calculate the desired metric. SFDR calculation is done as shown in the following code snippets. MATLAB Python % calculating SFDR using the time - domain waveform err_code = libpointer ( 'uint32Ptr' , 0 ); fft_len = libpointer ( 'uint64Ptr' , 0 ); metric = char ( 'SFDR' ); fft_time_re = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); fft_time_im = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); y_interleaved = [ y_re '; y_im' ]; y_interleaved = y_interleaved (:); y_interleavedPtr = libpointer ( 'int32Ptr' , y_interleaved ); sfdr_time = calllib ( 'libgenalyzer' , 'gn_metric' , c , y_interleavedPtr , metric , fft_time_re , fft_time_im , fft_len , err_code ); # compute SFDR result , fft_i , fft_q , err_code = genalyzer . metric_t ( c , x_intrlv , \"SFDR\" ) Note that the FFT calculated for analysis and computing the desired metric is returned by genalyzer. Plotting the FFT computed using genalyzer, we can see that the second harmonic at 4 MHz and its image dominate the remaining spurs. Note that the third harmonic and its image are filtered out by the programmable filter coefficients loaded into ADALM-PLUTO. Since SFDR is by definition, free of spurious frequencies, by examining the above plot, one can estimate SFDR to be around 50 dBc. This values agrees with the SFDR computed by genalyzer. SFDR ( time ) - 49.742253 Note that genalyzer can be configured to compute performance metrics from frequency-domain data as well. In other words, genalyzer can be configured to skip the FFT computation step and only perform analysis of the FFT provided as input. Note that passing a 1 instead of a 0 to the domain argument controls this configuration. This is shown by the MATLAB code snippet below. The same can be accomplished using Python bindings as well. MATLAB Python % setup measurement for freq - domain measurement c = libpointer ; domain = 1 ; % 0 - TIME ; 1 - FREQ calllib ( 'libgenalyzer' , 'gn_config_tone_meas' , ... c , domain , type , nfft , navg , fs , fsr , res , window , false , false , false ); % calculating SFDR using the FFT calculated from time - domain waveform err_code = libpointer ( 'uint32Ptr' , 0 ); fft_len = libpointer ( 'uint64Ptr' , 0 ); fft_y = fft ( hann ( length ( y )) .* y ); ffty_interleaved = [ real ( fft_y ) '; imag(fft_y).' ]; ffty_interleaved = ffty_interleaved (:); ffty_interleavedPtr = libpointer ( 'doublePtr' , ffty_interleaved ); fft_freq_re = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); fft_freq_im = libpointer ( 'doublePtrPtr' , zeros ( nfft , 1 )); sfdr_freq = calllib ( 'libgenalyzer' , 'gn_metric' , c , ffty_interleavedPtr , metric , fft_freq_re , fft_freq_im , fft_len , err_code ); # update domain inputs [ \"domain_wf\" ] = 1 config_obj = genalyzer . gn_params ( ** inputs ) c = genalyzer . config_tone_meas ( config_obj ) # compute SFDR result , fft_i , fft_q , err_code = genalyzer . metric_t ( c , x_intrlv , \"SFDR\" ) The calculated SFDR matches the corresponding result obtained using time-domain waveform closely. SFDR (freq) - 49.742421 Similarly, Signal-to-Noise-and-Distortion (SINAD, or S/(N + D) is the ratio of the rms signal amplitude to the mean value of the root-sum-square (RSS) of all other spectral components, including harmonics, but excluding DC. SINAD is a therefore, an indicator of the overall dynamic performance of an ADC because it includes all components which make up noise and distortion. To compute SINAD, only the","title":"Simulation"},{"location":"theory/","text":"Using Genalyzer As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(...); /* waveform generation and quantize */ // gen_tone(...); // quantize(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; } Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; } Test Configuration As indicated in the overall skelton C-script that interfaces with genalyzer, the first stage involves configuring an opaque struct that is provided to the users in order to describe the measurement scenario. Here, users can select between three config_*_meas() function calls in order to select between tone-, ramp- and noise-based performance metric calculations. The opaque struct maintains the state of the test scenario and is passed to the waveform generation and performance metric computation stages subsequently. Tone-based Test Configuration In tone-based test configuration, config_tone_meas() allows users to indicate test settings such as, number of tones, their frequencies, phases, scales, whether real sinusoidal or complex-exponential waveforms are to be generated, the sample-rate, full-scale range of the converter, its resolution etc. Similarly, users can indicate whether the data that will be loaded in the second stage is time-series data or interleaved FFT samples. Moreover, in data-capture scenario i.e., when FFT data is provided to Genalyzer in the second step, the tone frequency, scale and phase information is not required. This test configuration is used for measurements such as SFDR, THD, TIL etc. An example of the config_tone_meas() function call is shown by the following example. // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range 0 , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); Ramp-based Test Configuration In ramp-based test configuration, config_ramp_meas() allows users to indicate test settings such as, the starting and ending values of the ramp waveform in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used in non-linearity based measurements. An example of the config_ramp_meas() function call is shown by the following example. // configuration config_ramp_nl_meas ( & c , npts , // # of data points fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting start , stop , 0.0 ); Noise-based Test Configuration In noise-based test configuration, config_noise_meas() allows users to indicate test settings such as, the noise power level in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used for computing noise spectral density. An example of the config_noise_meas() function call is shown by the following example. // configuration config_noise_meas ( & c , COMPLEX_NOISE , nfft , navg , fs , fsr , res , noise_pwr_lvl , update_fsample , update_fdata , update_fshift ); Waveform Generation The second step, as shown previously, involves either generating the waveform and quantizing it or loading the waveform from a file. The following options are currently supported. cosine/sine and complex exponential waveforms of arbitrary frequency and sample rate ramp waveform Gaussian noise waveform of desired noise power spectral density level In all three cases, the waveform generation functions take two arguments, the opaque configuration struct that has been populated in the first step and a double pointer that will contain the analog waveform generated. The subsequent call to quantize() takes the configuration struct, the analog input waveform and the output quantized waveform obtained from quantizeing the analog waveform based on the resolution contained in the configuration struct. Alternatively, if data is loaded from a file, the configuration struct generated in the first stage will serve as a descriptor of that data. Note that indicating whether time or frequency data is loaded is indicated simply by an argument to the config_tone_meas() call in the first step. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"genalyzer_cwrapper.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(&c, FREQ, ...); // config_tone_meas(&c, TIME,...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; } Performance Metric Computation The final stage involves simply computing the desired performance metric. Metric computation is done by a call to metric() where, the last argument is one of: \"FSNR\" \"NSD\" \"SFDR\" \"SINAD\" \"SNR\" \"TD\" \"THD\" \"TIL Again, the test configuration contained in the opaque struct obtained from the first step is helpful in determinging whether the","title":"Usage Model"},{"location":"theory/#using-genalyzer","text":"As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(...); /* waveform generation and quantize */ // gen_tone(...); // quantize(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; } Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. #include \"cgenalyzer.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; }","title":"Using Genalyzer"},{"location":"theory/#test-configuration","text":"As indicated in the overall skelton C-script that interfaces with genalyzer, the first stage involves configuring an opaque struct that is provided to the users in order to describe the measurement scenario. Here, users can select between three config_*_meas() function calls in order to select between tone-, ramp- and noise-based performance metric calculations. The opaque struct maintains the state of the test scenario and is passed to the waveform generation and performance metric computation stages subsequently. Tone-based Test Configuration In tone-based test configuration, config_tone_meas() allows users to indicate test settings such as, number of tones, their frequencies, phases, scales, whether real sinusoidal or complex-exponential waveforms are to be generated, the sample-rate, full-scale range of the converter, its resolution etc. Similarly, users can indicate whether the data that will be loaded in the second stage is time-series data or interleaved FFT samples. Moreover, in data-capture scenario i.e., when FFT data is provided to Genalyzer in the second step, the tone frequency, scale and phase information is not required. This test configuration is used for measurements such as SFDR, THD, TIL etc. An example of the config_tone_meas() function call is shown by the following example. // configuration config_tone_meas ( & c , domain_wf , type_wf , nfft , // FFT order navg , // # of FFTs averaged fs , // sample rate fsr , // full-scale range 0 , // ADC resolution: unused configuration setting freq , // tone frequency, # of array elements = num_tones scale , // tone scale, # of array elements = num_tones phase , // tone phase, # of array elements = num_tones num_tones , // # of tones false , false , false ); Ramp-based Test Configuration In ramp-based test configuration, config_ramp_meas() allows users to indicate test settings such as, the starting and ending values of the ramp waveform in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used in non-linearity based measurements. An example of the config_ramp_meas() function call is shown by the following example. // configuration config_ramp_nl_meas ( & c , npts , // # of data points fs , // sample rate fsr , // full-scale range res , // ADC resolution: unused configuration setting start , stop , 0.0 ); Noise-based Test Configuration In noise-based test configuration, config_noise_meas() allows users to indicate test settings such as, the noise power level in addition to the full-scale range and the resolution of the data converter under test. This test configuration is primarily used for computing noise spectral density. An example of the config_noise_meas() function call is shown by the following example. // configuration config_noise_meas ( & c , COMPLEX_NOISE , nfft , navg , fs , fsr , res , noise_pwr_lvl , update_fsample , update_fdata , update_fshift );","title":"Test Configuration"},{"location":"theory/#waveform-generation","text":"The second step, as shown previously, involves either generating the waveform and quantizing it or loading the waveform from a file. The following options are currently supported. cosine/sine and complex exponential waveforms of arbitrary frequency and sample rate ramp waveform Gaussian noise waveform of desired noise power spectral density level In all three cases, the waveform generation functions take two arguments, the opaque configuration struct that has been populated in the first step and a double pointer that will contain the analog waveform generated. The subsequent call to quantize() takes the configuration struct, the analog input waveform and the output quantized waveform obtained from quantizeing the analog waveform based on the resolution contained in the configuration struct. Alternatively, if data is loaded from a file, the configuration struct generated in the first stage will serve as a descriptor of that data. Note that indicating whether time or frequency data is loaded is indicated simply by an argument to the config_tone_meas() call in the first step. #include <stdbool.h> #include <assert.h> #include <stdlib.h> #include \"genalyzer_cwrapper.h\" int main ( int argc , char * argv []) { // opaque config struct that will contain config settings // config c = NULL; /* configuration */ // config_tone_meas(&c, FREQ, ...); // config_tone_meas(&c, TIME,...); /* load waveform generation*/ // read_file_to_array(...); /* compute metrics */ // fsnr_val = metric(..., \"FSNR\"); return 0 ; }","title":"Waveform Generation"},{"location":"theory/#performance-metric-computation","text":"The final stage involves simply computing the desired performance metric. Metric computation is done by a call to metric() where, the last argument is one of: \"FSNR\" \"NSD\" \"SFDR\" \"SINAD\" \"SNR\" \"TD\" \"THD\" \"TIL Again, the test configuration contained in the opaque struct obtained from the first step is helpful in determinging whether the","title":"Performance Metric Computation"},{"location":"using_genalyzer/","text":"Using Genalyzer As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. ``` c include \"cgenalyzer.h\" int main(int argc, char *argv[]) { // opaque config struct that will contain config settings // config c = NULL; / configuration / // config_tone_meas(...); / waveform generation and quantize / // gen_tone(...); // quantize(...); / compute metrics / // fsnr_val = metric(..., \"FSNR\"); return 0; }``` .. literalinclude:: general_example_skelton1.c :language: C Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. .. literalinclude:: general_example_skelton2.c :language: C .. include:: 02a_test_configuration.rst .. include:: 02b_waveform_generation.rst .. include:: 02c_perf_metric_computation.rst","title":"Using genalyzer"},{"location":"using_genalyzer/#using-genalyzer","text":"As mentioned previously, Genalyzer is a C++ library designed to support computation of RF performance metrics using either simulation data or data captured from a physical instrument. Bindings are provided to enable users to write C- or Python-based scripts to compute the desired performance metrics. In both cases, the overall structure of a C-example script that links to genalyzer library is similar, as shown in the next section. The overall structure in a simulation-only scenario consists of three stages: Test Configuration Waveform Generation Metric Computation In the data-capture scenario, where the response of a data-converter is available in the form of text files, the structure would be Test Configuration Waveform Loading Metric Computation That is, only the second step in the procedure involved would change. The overall structure of a C-example that utilizes genalyzer library in the simulation-only scenario is shown by the following example. ``` c","title":"Using Genalyzer"},{"location":"using_genalyzer/#include-cgenalyzerh","text":"int main(int argc, char *argv[]) { // opaque config struct that will contain config settings // config c = NULL; / configuration / // config_tone_meas(...); / waveform generation and quantize / // gen_tone(...); // quantize(...); / compute metrics / // fsnr_val = metric(..., \"FSNR\"); return 0; }``` .. literalinclude:: general_example_skelton1.c :language: C Similarly, the overall structure of a C-example in the data-capture scenario is shown by the following example. .. literalinclude:: general_example_skelton2.c :language: C .. include:: 02a_test_configuration.rst .. include:: 02b_waveform_generation.rst .. include:: 02c_perf_metric_computation.rst","title":"include \"cgenalyzer.h\""}]}